-- This script is autogenerated from the tool DbTools. Do not edit manually.

-- cancelorder.sql:
CREATE OR REPLACE FUNCTION notifications.cancelorder(
    _alternateid uuid,
    _creatorname text
)
RETURNS TABLE(
    cancelallowed boolean,
    alternateid uuid,
    creatorname text,
    sendersreference text,
    created timestamp with time zone,                  
    requestedsendtime timestamp with time zone,
    processed timestamp with time zone,
    processedstatus orderprocessingstate,
    notificationchannel text,
    ignorereservation boolean,
    resourceid text,
    conditionendpoint text,
    generatedemailcount bigint,
    succeededemailcount bigint,
    generatedsmscount bigint, 
    succeededsmscount bigint
) 
LANGUAGE plpgsql
AS $$
DECLARE
    order_record RECORD;
BEGIN
    -- Retrieve the order and its status
    SELECT o.requestedsendtime, o.processedstatus
    INTO order_record
    FROM notifications.orders o
    WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname;

    -- If no order is found, return an empty result set
    IF NOT FOUND THEN
        RETURN;
    END IF;
    
     -- Check if order is already cancelled
     IF order_record.processedstatus = 'Cancelled' THEN
        RETURN QUERY 
        SELECT TRUE AS cancelallowed,
           order_details.*
        FROM notifications.getorder_includestatus_v4(_alternateid, _creatorname) AS order_details;
     ELSIF (order_record.requestedsendtime <= NOW() + INTERVAL '5 minutes' or order_record.processedstatus != 'Registered') THEN
        RETURN QUERY 
        SELECT FALSE AS cancelallowed, NULL::uuid, NULL::text, NULL::text, NULL::timestamp with time zone, NULL::timestamp with time zone, NULL::timestamp with time zone, NULL::orderprocessingstate, NULL::text, NULL::boolean, NULL::text, NULL::text, NULL::bigint, NULL::bigint, NULL::bigint, NULL::bigint;
     ELSE 
        -- Cancel the order by updating its status
        UPDATE notifications.orders o
        SET processedstatus = 'Cancelled', processed = NOW()
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname;

        -- Retrieve the updated order details
        RETURN QUERY 
        SELECT TRUE AS cancelallowed,
               order_details.*
        FROM notifications.getorder_includestatus_v4(_alternateid, _creatorname) AS order_details;
    END IF;      
END;
$$;


-- getemailrecipients.sql:
CREATE OR REPLACE FUNCTION notifications.getemailrecipients_v2(_alternateid uuid)
RETURNS TABLE(
    recipientorgno text, 
    recipientnin text, 
    toaddress text
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
__orderid BIGINT := (SELECT _id from notifications.orders
			where alternateid = _alternateid);
BEGIN
RETURN query 
	SELECT e.recipientorgno, e.recipientnin, e.toaddress
	FROM notifications.emailnotifications e
	WHERE e._orderid = __orderid;
END;
$BODY$;

-- getemailsstatusnewupdatestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getemails_statusnew_updatestatus()
    RETURNS TABLE(alternateid uuid, subject text, body text, fromaddress text, toaddress text, contenttype text) 
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    latest_email_timeout TIMESTAMP WITH TIME ZONE;
BEGIN
    SELECT emaillimittimeout 
    INTO latest_email_timeout 
    FROM notifications.resourcelimitlog 
    WHERE id = (SELECT MAX(id) FROM notifications.resourcelimitlog);

    -- Check if the latest email timeout is set and valid
    IF latest_email_timeout IS NOT NULL THEN
        IF latest_email_timeout >= NOW() THEN
            RETURN QUERY 
            SELECT NULL::uuid AS alternateid, 
                   NULL::text AS subject, 
                   NULL::text AS body, 
                   NULL::text AS fromaddress, 
                   NULL::text AS toaddress, 
                   NULL::text AS contenttype 
            WHERE FALSE;
            RETURN;
        ELSE 
            UPDATE notifications.resourcelimitlog 
            SET emaillimittimeout = NULL 
            WHERE id = (SELECT MAX(id) FROM notifications.resourcelimitlog);
        END IF;
    END IF;
    
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.emailnotifications
        SET result = 'Sending', resulttime = now()
        WHERE result = 'New' 
        RETURNING notifications.emailnotifications.alternateid, 
                  _orderid, 
                  notifications.emailnotifications.toaddress, 
                  notifications.emailnotifications.customizedsubject, 
                  notifications.emailnotifications.customizedbody
    )
    SELECT u.alternateid, 
           CASE WHEN u.customizedsubject IS NOT NULL AND u.customizedsubject <> '' THEN u.customizedsubject ELSE et.subject END AS subject, 
           CASE WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' THEN u.customizedbody ELSE et.body END AS body, 
           et.fromaddress, 
           u.toaddress, 
           et.contenttype 
    FROM updated u
    JOIN notifications.emailtexts et ON u._orderid = et._orderid;    
END;
$BODY$;


-- getemailsummary.sql:
CREATE OR REPLACE FUNCTION notifications.getemailsummary_v2(
	_alternateorderid uuid,
	_creatorname text)
    RETURNS TABLE(
        sendersreference text, 
        alternateid uuid, 
        recipientorgno text, 
        recipientnin text, 
        toaddress text, 
        result emailnotificationresulttype, 
        resulttime timestamptz) 
    LANGUAGE 'plpgsql'
AS $BODY$

	BEGIN
		RETURN QUERY
		   SELECT o.sendersreference, n.alternateid, n.recipientorgno, n.recipientnin, n.toaddress, n.result, n.resulttime
			FROM notifications.emailnotifications n
            LEFT JOIN notifications.orders o ON n._orderid = o._id
			WHERE o.alternateid = _alternateorderid
			and o.creatorname = _creatorname;
        IF NOT FOUND THEN
            RETURN QUERY
            SELECT o.sendersreference, NULL::uuid, NULL::text, NULL::text, NULL::text, NULL::emailnotificationresulttype, NULL::timestamptz
            FROM notifications.orders o
            WHERE o.alternateid = _alternateorderid
            and o.creatorname = _creatorname;
        END IF;
	END;
$BODY$;

-- getinstantordertracking.sql:
CREATE OR REPLACE FUNCTION notifications.get_instant_order_tracking
(
    _creatorname text,
    _idempotencyid text
)
RETURNS TABLE (
    orders_chain_id uuid,
    shipment_id uuid,
    senders_reference text
) 
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        oc.orderid AS orders_chain_id,
        (oc.orderchain->>'OrderId')::uuid AS shipment_id,
        oc.orderchain->>'SendersReference' AS senders_reference
    FROM 
        notifications.orderschain oc
    WHERE 
        oc.creatorname = _creatorname
        AND oc.idempotencyid = _idempotencyid
        AND oc.orderchain->>'Type' = '2';
END;
$$;

COMMENT ON FUNCTION notifications.get_instant_order_tracking IS 
'Retrieves tracking information for an instant notification order using the creator''s short name and idempotency identifier.
This function provides a streamlined version of order tracking specifically for instant notifications,
enabling idempotent operations by allowing clients to retrieve previously submitted
notification information without creating duplicates.
Parameters:
- _creatorname: The short name of the creator that originally submitted the notification order
- _idempotencyid: The idempotency identifier that was defined when the order was created
Returns a table with the following columns:
- orders_chain_id: The unique identifier for the notification order in the system
- shipment_id: The unique identifier for the notification shipment
- senders_reference: The sender''s reference for the notification (may be null)';

-- getmetrics.sql:
CREATE OR REPLACE FUNCTION notifications.getmetrics(
    month_input int,
    year_input int
)
RETURNS TABLE (
    org text,
    placed_orders bigint,
    sent_emails bigint,
    succeeded_emails bigint,
    sent_sms bigint,
    succeeded_sms bigint
)
AS $$
BEGIN
    RETURN QUERY
    SELECT
        o.creatorname,
        COUNT(DISTINCT o._id) AS placed_orders,
        SUM(CASE WHEN e._id IS NOT NULL THEN 1 ELSE 0 END) AS sent_emails,
        SUM(CASE WHEN e.result IN ('Delivered', 'Succeeded') THEN 1 ELSE 0 END) AS succeeded_emails, 
        SUM(CASE WHEN s._id IS NOT NULL THEN s.smscount ELSE 0 END) AS sent_sms,
        SUM(CASE WHEN s.result = 'Accepted' THEN 1 ELSE 0 END) AS succeeded_sms
    FROM notifications.orders o
    LEFT JOIN notifications.emailnotifications e ON o._id = e._orderid
    LEFT JOIN notifications.smsnotifications s ON o._id = s._orderid
    WHERE EXTRACT(MONTH FROM o.requestedsendtime) = month_input
        AND EXTRACT(YEAR FROM o.requestedsendtime) = year_input
    GROUP BY o.creatorname;
END;
$$ LANGUAGE plpgsql;


-- getorderincludestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getorder_includestatus_v4(
    _alternateid uuid,
    _creatorname text
)
RETURNS TABLE(
    alternateid uuid,
    creatorname text,
    sendersreference text,
    created timestamp with time zone,                  
    requestedsendtime timestamp with time zone,
    processed timestamp with time zone,
    processedstatus orderprocessingstate,
    notificationchannel text,
    ignorereservation boolean,
    resourceid text,
    conditionendpoint text,
    generatedemailcount bigint,
    succeededemailcount bigint,
    generatedsmscount bigint, 
    succeededsmscount bigint
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    _target_orderid INTEGER;
    _succeededEmailCount BIGINT;
    _generatedEmailCount BIGINT;
    _succeededSmsCount BIGINT;
    _generatedSmsCount BIGINT;
BEGIN
    SELECT _id INTO _target_orderid 
    FROM notifications.orders
    WHERE orders.alternateid = _alternateid 
    AND orders.creatorname = _creatorname;
    
    SELECT
        SUM(CASE WHEN result IN ('Delivered', 'Succeeded') THEN 1 ELSE 0 END), 
        COUNT(1) AS generatedEmailCount
    INTO _succeededEmailCount, _generatedEmailCount
    FROM notifications.emailnotifications
    WHERE emailnotifications._orderid = _target_orderid;
    
    SELECT      
        SUM(CASE WHEN result = 'Accepted' THEN 1 ELSE 0 END), 
        COUNT(1) AS generatedSmsCount
    INTO _succeededSmsCount, _generatedSmsCount
    FROM notifications.smsnotifications
    WHERE smsnotifications._orderid = _target_orderid;

    RETURN QUERY
    SELECT 
        orders.alternateid,
        orders.creatorname,
        orders.sendersreference,
        orders.created,
        orders.requestedsendtime,
        orders.processed,
        orders.processedstatus,
        orders.notificationorder->>'NotificationChannel',
        CASE 
            WHEN orders.notificationorder->>'IgnoreReservation' IS NULL THEN NULL
            ELSE (orders.notificationorder->>'IgnoreReservation')::BOOLEAN
        END AS IgnoreReservation,
        orders.notificationorder->>'ResourceId',
        orders.notificationorder->>'ConditionEndpoint',
        _generatedEmailCount,
        _succeededEmailCount,
        _generatedSmsCount, 
        _succeededSmsCount
    FROM
        notifications.orders AS orders
    WHERE 
        orders._id = _target_orderid;
END;
$BODY$;


-- getorderschaintracking.sql:
-- Retrieves tracking information for a notification order chain using the creator's short name and idempotency identifier.
CREATE OR REPLACE FUNCTION notifications.get_orders_chain_tracking
(
    _creatorname text,
    _idempotencyid text
)
RETURNS TABLE (
    orders_chain_id uuid,
    shipment_id uuid,
    senders_reference text,
    reminders jsonb
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_record_exists boolean;
BEGIN
    -- Check if record exists first to provide better error handling
    SELECT EXISTS (
        SELECT 1 
        FROM notifications.orderschain 
        WHERE creatorname = _creatorname
        AND idempotencyid = _idempotencyid
        -- exclude type 'Instant' from results
		AND (orderchain->>'Type' <> '2' OR orderchain->>'Type' IS NULL) 
    ) INTO v_record_exists;
    
    IF NOT v_record_exists THEN
        -- Return empty result set with no rows
        RETURN;
    END IF;

    RETURN QUERY
    SELECT 
        orders_chain.orderid AS orders_chain_id,
        (orders_chain.orderchain->>'OrderId')::uuid AS shipment_id,
        orders_chain.orderchain->>'SendersReference' AS senders_reference,
        -- Extract only OrderId and SendersReference from each reminder
        COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'ShipmentId', reminder->>'OrderId',
                    'SendersReference', reminder->>'SendersReference'
                )
            )
            FROM jsonb_array_elements(
                CASE 
                    WHEN jsonb_typeof(orders_chain.orderchain->'Reminders') = 'array' AND 
                         (orders_chain.orderchain->'Reminders') IS NOT NULL AND
                         (orders_chain.orderchain->'Reminders') <> 'null'::jsonb
                    THEN orders_chain.orderchain->'Reminders'
                    ELSE '[]'::jsonb
                END
            ) AS reminder),
            '[]'::jsonb
        ) AS reminders
    FROM 
        notifications.orderschain orders_chain
    WHERE 
        orders_chain.creatorname = _creatorname
        AND orders_chain.idempotencyid = _idempotencyid;
END;
$BODY$;

COMMENT ON FUNCTION notifications.get_orders_chain_tracking IS 
'Retrieves tracking information for a notification order chain using the creator''s short name and idempotency identifier.

This function enables idempotent operations by allowing clients to retrieve previously submitted
notification chain information without creating duplicates. It specifically excludes order chains where the type is ''Instant'' (i.e., where the ''Type'' field in the orderchain data is ''2'').

Parameters:
- _creatorname: The short name of the creator that originally submitted the notification order chain
- _idempotencyid: The idempotency identifier that was defined when the order chain was created

Returns a table with the following columns:
- orders_chain_id: The unique identifier for the entire notification order chain
- shipment_id: The unique identifier for the main notification order
- senders_reference: The sender''s reference for the main notification order (may be null)
- reminders: A JSON array containing tracking information for any reminder notifications

The reminders JSON array contains objects with the following structure:
- OrderId: The unique identifier for the reminder notification order
- SendersReference: The sender''s reference for the reminder notification (may be null).';


-- getorderspastsendtimeupdatestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getorders_pastsendtime_updatestatus()
    RETURNS TABLE(notificationorders jsonb)
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
RETURN QUERY
	UPDATE notifications.orders
	SET processedstatus = 'Processing'
	WHERE _id IN (select _id
				 from notifications.orders
				 where processedstatus = 'Registered'
				 and requestedsendtime <= now() + INTERVAL '1 minute'
				 limit 50)
	RETURNING notificationorder AS notificationorders;
END;
$BODY$;

-- getshipmentforstatusfeed.sql:
CREATE OR REPLACE FUNCTION notifications.getshipmentforstatusfeed(_alternateid uuid)
RETURNS TABLE(
    alternateid uuid,
    reference text,
    status text,
    last_update timestamp with time zone,
    destination text,
    type text
)
LANGUAGE 'plpgsql'
COST 100
VOLATILE PARALLEL UNSAFE
ROWS 1000
AS $BODY$
BEGIN
    RETURN QUERY
    WITH distinct_orders AS (
        SELECT DISTINCT ON (o._id) o.*
        FROM notifications.orders o
        LEFT JOIN notifications.emailnotifications e ON e._orderid = o._id
        LEFT JOIN notifications.smsnotifications s ON s._orderid = o._id
        WHERE e.alternateid = _alternateid OR s.alternateid = _alternateid
    )
    SELECT
        o.alternateid,
        t.reference,      
        t.status,
        t.last_update,
        t.destination,
        t.type
    FROM
        distinct_orders o
        CROSS JOIN LATERAL notifications.get_shipment_tracking_v2(o.alternateid, o.creatorname) AS t;

END;
$BODY$;

ALTER FUNCTION notifications.getshipmentforstatusfeed(uuid)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.getshipmentforstatusfeed(uuid)
    IS 'Retrieves combined order and shipment tracking data based on an email or sms notification alternateid.';

-- getshipmenttracking.sql:
CREATE OR REPLACE FUNCTION notifications.get_shipment_tracking(
    _alternateid UUID,
    _creatorname TEXT)
RETURNS TABLE (
    reference     TEXT,
    status        TEXT,
    last_update   TIMESTAMPTZ,
    destination   TEXT
) AS $$
DECLARE
    v_order_exists BOOLEAN;
BEGIN
    -- Check for the existence of the order
    SELECT EXISTS (
        SELECT 1
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    )
    INTO v_order_exists;

    -- Return empty set if no order is found
    IF NOT v_order_exists THEN
        RETURN;
    END IF;

    -- Return combined tracking info
    RETURN QUERY
    WITH order_data AS (
        SELECT o._id, o.sendersreference, o.created, o.processed, o.processedstatus
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    ),
    order_tracking AS (
        SELECT
            od.sendersreference AS reference,
            od.processedstatus::TEXT AS status,
            GREATEST(od.created, COALESCE(od.processed, od.created)) AS last_update,
            NULL::TEXT AS destination
        FROM order_data od
    ),
    email_tracking AS (
        SELECT
            od.sendersreference AS reference,
            e.result::TEXT AS status,
            e.resulttime AS last_update,
            e.toaddress AS destination
        FROM order_data od
        JOIN notifications.emailnotifications e ON e._orderid = od._id
    ),
    sms_tracking AS (
        SELECT
            od.sendersreference AS reference,
            s.result::TEXT AS status,
            s.resulttime AS last_update,
            s.mobilenumber AS destination
        FROM order_data od
        JOIN notifications.smsnotifications s ON s._orderid = od._id
    )
    SELECT * FROM order_tracking
    UNION ALL
    SELECT * FROM email_tracking
    UNION ALL
    SELECT * FROM sms_tracking;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.get_shipment_tracking(UUID, TEXT) IS
'Returns delivery tracking information for a notification identified by the given alternate identifier and creator name.

Includes:
 - Order-level tracking (reference and status)
 - Email notification tracking (status, result time, destination)
 - SMS notification tracking (status, result time, destination)

If no matching order exists, an empty result set is returned.';


-- This is a new version to return the type of the notification
CREATE OR REPLACE FUNCTION notifications.get_shipment_tracking_v2(
    _alternateid UUID,
    _creatorname TEXT)
RETURNS TABLE (
    reference     TEXT,
    status        TEXT,
    last_update   TIMESTAMPTZ,
    destination   TEXT,
    type          TEXT
) AS $$
DECLARE
    v_order_exists BOOLEAN;
BEGIN
    -- Check for the existence of the order
    SELECT EXISTS (
        SELECT 1
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    )
    INTO v_order_exists;

    -- Return empty set if no order is found
    IF NOT v_order_exists THEN
        RETURN;
    END IF;

    -- Return combined tracking info
    RETURN QUERY
    WITH order_data AS (
        SELECT o._id, o.sendersreference, o.created, o.processed, o.processedstatus, o.type
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    ),
    order_tracking AS (
        SELECT
            od.sendersreference AS reference,
            od.processedstatus::TEXT AS status,
            GREATEST(od.created, COALESCE(od.processed, od.created)) AS last_update,
            NULL::TEXT AS destination,
            od.type::TEXT AS type
        FROM order_data od
    ),
    email_tracking AS (
        SELECT
            od.sendersreference AS reference,
            e.result::TEXT AS status,
            e.resulttime AS last_update,
            e.toaddress AS destination,
            od.type::TEXT AS type
        FROM order_data od
        JOIN notifications.emailnotifications e ON e._orderid = od._id
    ),
    sms_tracking AS (
        SELECT
            od.sendersreference AS reference,
            s.result::TEXT AS status,
            s.resulttime AS last_update,
            s.mobilenumber AS destination,
            od.type::TEXT AS type
        FROM order_data od
        JOIN notifications.smsnotifications s ON s._orderid = od._id
    )
    SELECT * FROM order_tracking
    UNION ALL
    SELECT * FROM email_tracking
    UNION ALL
    SELECT * FROM sms_tracking;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.get_shipment_tracking_v2(UUID, TEXT) IS
'Returns delivery tracking information for a notification identified by the given alternate identifier and creator name.

Includes:
 - Order-level tracking (reference and status)
 - Email notification tracking (status, result time, destination)
 - SMS notification tracking (status, result time, destination)

If no matching order exists, an empty result set is returned.';


-- getsmsrecipients.sql:
CREATE OR REPLACE FUNCTION notifications.getsmsrecipients_v2(_orderid uuid)
RETURNS TABLE(
  recipientorgno text, 
  recipientnin text,
  mobilenumber text
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
__orderid BIGINT := (SELECT _id from notifications.orders
			where alternateid = _orderid);
BEGIN
RETURN query 
	SELECT s.recipientorgno, s.recipientnin, s.mobilenumber
	FROM notifications.smsnotifications s
	WHERE s._orderid = __orderid;
END;
$BODY$;

-- getsmsstatusnewupdatestatus.sql:
-- This function is kept for backward compatibility and may be removed in future versions.
-- Use notifications.getsms_statusnew_updatestatus(integer) instead.
CREATE OR REPLACE FUNCTION notifications.getsms_statusnew_updatestatus()
    RETURNS TABLE(alternateid uuid, sendernumber text, mobilenumber text, body text) 
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.smsnotifications
        SET result = 'Sending', resulttime = now()
        WHERE result = 'New' 
        RETURNING notifications.smsnotifications.alternateid, 
                  _orderid, 
                  notifications.smsnotifications.mobilenumber,
                  notifications.smsnotifications.customizedbody
    )
    SELECT u.alternateid, 
           st.sendernumber, 
           u.mobilenumber, 
           CASE WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' THEN u.customizedbody ELSE st.body END AS body
    FROM updated u
    JOIN notifications.smstexts st ON u._orderid = st._orderid;        
END;
$BODY$;

-- FUNCTION: notifications.getsms_statusnew_updatestatus(integer)
CREATE OR REPLACE FUNCTION NOTIFICATIONS.GETSMS_STATUSNEW_UPDATESTATUS (_SENDINGTIMEPOLICY INTEGER) 
RETURNS TABLE (
    ALTERNATEID UUID,
    SENDERNUMBER TEXT,
    MOBILENUMBER TEXT,
    BODY TEXT
) 
LANGUAGE 'plpgsql' 
COST 100 
VOLATILE 
PARALLEL UNSAFE 
ROWS 1000 
AS $BODY$
BEGIN
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.smsnotifications s
        SET result = 'Sending', resulttime = now()
        FROM notifications.orders o
        WHERE s.result = 'New' 
          AND s._orderid = o._id
          AND (
              (_sendingtimepolicy = 1 AND o.sendingtimepolicy = 1)
           OR (_sendingtimepolicy = 2 AND (o.sendingtimepolicy = 2 OR o.sendingtimepolicy IS NULL))
          )
        RETURNING s.alternateid, 
                  s._orderid, 
                  s.mobilenumber,
                  s.customizedbody
    )
    SELECT u.alternateid, 
           st.sendernumber, 
           u.mobilenumber, 
           CASE 
               WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' 
               THEN u.customizedbody 
               ELSE st.body 
           END AS body
    FROM updated u
    JOIN notifications.smstexts st ON u._orderid = st._orderid;
END;
$BODY$;

COMMENT ON FUNCTION NOTIFICATIONS.GETSMS_STATUSNEW_UPDATESTATUS (INTEGER) IS 'Reads all entries in smsnotifications where result status is New.
 Result is then updated to Sending. Parameter _sendingtimepolicy is used to
 filter the returned entries based on the policy for scheduling set on the related
 order row. If this is null, it is treated as Daytime, which is the default setting';


-- getsmssummary.sql:
CREATE OR REPLACE FUNCTION notifications.getsmssummary_v2(
	_alternateorderid uuid,
	_creatorname text)
    RETURNS TABLE(
        sendersreference text, 
        alternateid uuid, 
        recipientorgno text, 
        recipientnin text, 
        mobilenumber text, 
        result smsnotificationresulttype, 
        resulttime timestamptz) 
    LANGUAGE 'plpgsql'
AS $BODY$

	BEGIN
		RETURN QUERY
		   SELECT o.sendersreference, n.alternateid, n.recipientorgno, n.recipientnin, n.mobilenumber, n.result, n.resulttime
			FROM notifications.smsnotifications n
            LEFT JOIN notifications.orders o ON n._orderid = o._id
			WHERE o.alternateid = _alternateorderid
			and o.creatorname = _creatorname;
        IF NOT FOUND THEN
            RETURN QUERY
            SELECT o.sendersreference, NULL::uuid, NULL::text, NULL::text, NULL::text, NULL::smsnotificationresulttype, NULL::timestamptz
            FROM notifications.orders o
            WHERE o.alternateid = _alternateorderid
            and o.creatorname = _creatorname;
        END IF;
	END;
$BODY$;

-- getstatusfeed.sql:
CREATE OR REPLACE FUNCTION notifications.getstatusfeed(
    _sequencenumber BIGINT,
    _creatorname TEXT,
    _limit INTEGER
)
RETURNS TABLE(_id BIGINT, orderstatus jsonb) AS $$
BEGIN
    /*
     * This function retrieves recent status feed entries for a specific creator.
     *
     * PARAMETERS:
     * _sequencenumber: The ID to look after. The function will return rows where _id > this value.
     * _creator_name:   The name of the creator to filter by.
     * _limit:          The maximum number of rows to return.
     *
     * RETURNS:
     * A table with two columns: _id (BIGINT) and orderstatus (TEXT).
     */
    RETURN QUERY
    SELECT
        sf._id,
        sf.orderstatus
    FROM
        notifications.statusfeed AS sf
    WHERE
        sf._id > _sequencenumber
        AND sf.creatorname = _creatorname
        AND sf.created < (NOW() - INTERVAL '2 seconds')
    ORDER BY
        sf._id ASC
    LIMIT
        _limit;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

COMMENT ON FUNCTION notifications.getstatusfeed(BIGINT, TEXT, INTEGER) IS 'Retrieves a limited number of statusfeed entries created more than 2 seconds ago for a specific creator, starting after a given sequence number.';


-- insertemailnotification.sql:
CREATE OR REPLACE PROCEDURE notifications.insertemailnotification(
    _orderid uuid,
    _alternateid uuid,
    _recipientorgno TEXT,
    _recipientnin TEXT,
    _toaddress TEXT,
    _customizedbody TEXT,
    _customizedsubject TEXT,
    _result TEXT,
    _resulttime timestamptz,
    _expirytime timestamptz
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    __orderid BIGINT;
BEGIN
    SELECT _id INTO __orderid 
    FROM notifications.orders
    WHERE alternateid = _orderid;

    INSERT INTO notifications.emailnotifications(
        _orderid,
        alternateid,
        recipientorgno,
        recipientnin,
        toaddress,
        customizedbody,
        customizedsubject,
        result,
        resulttime,
        expirytime
    )
    VALUES (
        __orderid,
        _alternateid,
        _recipientorgno,
        _recipientnin,
        _toaddress,
        _customizedbody,
        _customizedsubject,
        _result::emailnotificationresulttype,
        _resulttime,
        _expirytime
    );
END;
$BODY$;

-- insertemailtext.sql:
CREATE OR REPLACE PROCEDURE notifications.insertemailtext(__orderid BIGINT, _fromaddress TEXT, _subject TEXT, _body TEXT, _contenttype TEXT)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
INSERT INTO notifications.emailtexts(_orderid, fromaddress, subject, body, contenttype)
	VALUES (__orderid, _fromaddress, _subject, _body, _contenttype);
END;
$BODY$;


-- insertorder.sql:
CREATE OR REPLACE FUNCTION notifications.insertorder(_alternateid UUID, _creatorname TEXT, _sendersreference TEXT, _created TIMESTAMPTZ, _requestedsendtime TIMESTAMPTZ, _notificationorder JSONB)
RETURNS BIGINT
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Postgres supports function overloading - so this function has the same name, but one additional parameter: sendingTimePolicy
CREATE OR REPLACE FUNCTION notifications.insertorder(
	_alternateid uuid,
	_creatorname text,
	_sendersreference text,
	_created timestamp with time zone,
	_requestedsendtime timestamp with time zone,
	_notificationorder jsonb,
	_sendingtimepolicy integer)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$

DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Add new overload that includes the 'type' parameter
CREATE OR REPLACE FUNCTION notifications.insertorder(
	_alternateid uuid,
	_creatorname text,
	_sendersreference text,
	_created timestamp with time zone,
	_requestedsendtime timestamp with time zone,
	_notificationorder jsonb,
	_sendingtimepolicy integer,
	_type text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$

DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy, type) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy, _type::public.notificationordertype)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Overload: Adds the 'processedstatus' parameter to allow explicit setting of the order's processing state.
CREATE OR REPLACE FUNCTION notifications.insertorder(
    _alternateid uuid,
    _creatorname text,
    _sendersreference text,
    _created timestamp with time zone,
    _requestedsendtime timestamp with time zone,
    _notificationorder jsonb,
    _sendingtimepolicy integer,
    _type text,
    _processingstatus text
)
RETURNS bigint
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    _orderid BIGINT;
BEGIN
    INSERT INTO notifications.orders(
        alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy, type, processedstatus
    )
    VALUES (
        _alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy, _type::public.notificationordertype, _processingstatus::public.orderprocessingstate
    )
    RETURNING _id INTO _orderid;

    RETURN _orderid;
END;
$BODY$;

-- insertorderchain.sql:
CREATE OR REPLACE PROCEDURE notifications.insertorderchain(
    _orderid UUID,
    _idempotencyid TEXT,
    _creatorname TEXT,
    _created TIMESTAMP with time zone,
    _orderchain JSONB
)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    INSERT INTO notifications.orderschain(
        orderid,
        idempotencyid,
        creatorname,
        created,
        processed,
        orderchain
    )
    VALUES (
        _orderid,
        _idempotencyid,
        _creatorname,
        _created,
        _created,
        _orderchain
    );
END;
$BODY$;


-- insertsmsnotification.sql:
CREATE OR REPLACE PROCEDURE notifications.insertsmsnotification(
    _orderid uuid,
    _alternateid uuid,
    _recipientorgno TEXT,
    _recipientnin TEXT,
    _mobilenumber TEXT,
    _customizedbody TEXT,
    _result TEXT,
    _smscount integer,
    _resulttime timestamptz,
    _expirytime timestamptz
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    __orderid BIGINT;
BEGIN
    SELECT _id INTO __orderid 
    FROM notifications.orders
    WHERE alternateid = _orderid;

    INSERT INTO notifications.smsnotifications(
        _orderid,
        alternateid,
        recipientorgno,
        recipientnin,
        mobilenumber,
        customizedbody,
        result,
        smscount,
        resulttime,
        expirytime
    )
    VALUES (
        __orderid,
        _alternateid,
        _recipientorgno,
        _recipientnin,
        _mobilenumber,
        _customizedbody,
        _result::smsnotificationresulttype,
        _smscount,
        _resulttime,
        _expirytime
    );
END;
$BODY$;

-- insertstatusfeed.sql:
-- FUNCTION: notifications.insertstatusfeed(bigint, text, jsonb)

-- DROP FUNCTION IF EXISTS notifications.insertstatusfeed(bigint, text, jsonb);

CREATE OR REPLACE FUNCTION notifications.insertstatusfeed(
	_orderid bigint,
	_creatorname text,
	_orderstatus jsonb)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    -- Insert the new status into the 'statusfeed' table
    INSERT INTO notifications.statusfeed (orderid, creatorname, created, orderstatus)
    VALUES (_orderid, _creatorname, now(), _orderstatus);
END;
$BODY$;

ALTER FUNCTION notifications.insertstatusfeed(bigint, text, jsonb)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.insertstatusfeed(bigint, text, jsonb) IS
'This function inserts a new status update record into the `notifications.statusfeed` table.

Arguments:
- _orderid (bigint): The unique identifier for the order being updated.
- _creatorname (text): The name of the service owner for which  the status entry is relevant.
- _orderstatus (jsonb): A JSONB object containing the specific details of the order status at this point in time.

The function automatically records the current timestamp (`now()`) for the `created` column upon insertion. It returns void.';


-- trymarkorderascompleted.sql:
CREATE OR REPLACE FUNCTION notifications.trymarkorderascompleted(_alternateid uuid, _alternateidsource text)
RETURNS boolean AS $$
DECLARE
    order_id bigint;
    order_status orderprocessingstate;
    has_pending_notifications boolean := false;
BEGIN
    IF _alternateid IS NULL THEN
        RAISE EXCEPTION 'Notification ID cannot be null';
    END IF;

    IF _alternateidsource IS NULL OR LENGTH(TRIM(_alternateidsource)) = 0 THEN
        RAISE EXCEPTION 'Notification type cannot be null or empty';
    END IF;

    -- Convert notification type to uppercase for case-insensitive comparison
    _alternateidsource := UPPER(TRIM(_alternateidsource));

    -- Step 2: Find the order ID based on notification type
    CASE _alternateidsource
        WHEN 'SMS' THEN
            SELECT _orderid INTO order_id 
            FROM notifications.smsnotifications 
            WHERE alternateid = _alternateid
            LIMIT 1;

        WHEN 'EMAIL' THEN
            SELECT _orderid INTO order_id 
            FROM notifications.emailnotifications 
            WHERE alternateid = _alternateid
            LIMIT 1;

        WHEN 'ORDER' THEN
            SELECT _id INTO order_id
            FROM notifications.orders
            WHERE alternateid = _alternateid
            LIMIT 1;

        ELSE
            RAISE EXCEPTION 'Invalid notification type: %. Must be one of: SMS, EMAIL, ORDER', _alternateidsource;
    END CASE;

    -- Step 3: Validate order ID exists
    IF order_id IS NULL THEN
        RAISE EXCEPTION 'No order found for notification ID % with source type %', _alternateid, _alternateidsource;
    END IF;

    -- Step 4: Check if order is already completed (with row lock)
    SELECT processedstatus INTO order_status
    FROM notifications.orders
    WHERE _id = order_id
    FOR UPDATE;

    IF order_status IS NULL OR (order_status <> 'Processing'::orderprocessingstate AND order_status <> 'Processed'::orderprocessingstate) THEN
        RETURN false;
    END IF;

    -- Step 5: Check if any notifications are still pending
    WITH pending_notifications AS (
        SELECT 1 AS is_pending
        FROM notifications.smsnotifications 
        WHERE _orderid = order_id 
        AND result IN ('New'::smsnotificationresulttype, 'Sending'::smsnotificationresulttype, 'Accepted'::smsnotificationresulttype)

        UNION ALL

        SELECT 1 AS is_pending
        FROM notifications.emailnotifications 
        WHERE _orderid = order_id 
        AND result IN ('New'::emailnotificationresulttype, 'Sending'::emailnotificationresulttype, 'Succeeded'::emailnotificationresulttype)
    )
    SELECT EXISTS(SELECT 1 FROM pending_notifications) INTO has_pending_notifications;

    -- Step 6: Update order status based on notification states
    UPDATE notifications.orders
    SET processedstatus = CASE 
                            WHEN has_pending_notifications THEN 'Processed'
                            ELSE 'Completed'
                          END::orderprocessingstate,
        processed = CURRENT_TIMESTAMP
    WHERE _id = order_id
    AND processedstatus IS DISTINCT FROM (CASE WHEN has_pending_notifications THEN 'Processed' ELSE 'Completed' END::orderprocessingstate);

    RETURN NOT has_pending_notifications;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.trymarkorderascompleted IS 
'Attempts to mark a notification order as completed based on the status
of its associated SMS and Email notifications. The function updates the order''s
status to ''Completed'' only if all associated notifications are no longer pending.

Parameters:
  _alternateid uuid       - The UUID identifier for the SMS, Email notifications or order
  _alternateidsource text - The source type, must be one of: ''SMS'', ''EMAIL'', or ''ORDER'' (case-insensitive)

Returns:
  boolean - TRUE if the order was successfully marked as completed
          FALSE if the order cannot be completed (already completed or has pending notifications)

Side Effects:
  - Updates the processedstatus and processed timestamp in notifications.orders table
  - Sets order status to ''Completed'' when no pending notifications exist
  - Sets order status to ''Processed'' when pending notifications still exist

Throws:
  - Exception if _alternateid is NULL
  - Exception if _alternateidsource is NULL or empty
  - Exception if _alternateidsource is not one of: ''SMS'', ''EMAIL'', ''ORDER''
  - Exception if no order is found for the given notification ID and source';

-- updateemailstatus.sql:
CREATE OR REPLACE PROCEDURE notifications.updateemailstatus(_alternateid UUID, _result text, _operationid text)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
	UPDATE notifications.emailnotifications 
	SET result = _result::emailnotificationresulttype, resulttime = now(), operationid = _operationid
	WHERE alternateid = _alternateid;
END;
$BODY$;

-- updateexpirednotifications.sql:
CREATE OR REPLACE FUNCTION notifications.updateexpirednotifications(
    _source TEXT,
    _limit INT
)
RETURNS SETOF UUID
LANGUAGE plpgsql
AS $$
BEGIN
    -- Use lower() for case-insensitive comparison of the notification type
    IF lower(_source) = 'email' THEN
        -- If the type is 'email', run the update on the emailnotifications table
        RETURN QUERY
        WITH updated_rows AS (
            UPDATE notifications.emailnotifications
            SET result = 'Failed_TTL',
                resulttime = now()
            WHERE _id IN (
                SELECT _id
                FROM notifications.emailnotifications
                WHERE result = 'Succeeded' AND expirytime < now()
                ORDER BY _id DESC
                LIMIT GREATEST(_limit, 1) -- Use the input parameter for the limit
            )
            RETURNING alternateid -- Return all alternateids from updated rows
        )
        -- Select the unique alternateids from the CTE
        SELECT DISTINCT alternateid
        FROM updated_rows;

    ELSIF lower(_source) = 'sms' THEN
        -- If the type is 'sms', run the update on the smsnotifications table
        RETURN QUERY
        WITH updated_rows AS (
            UPDATE notifications.smsnotifications
            SET result = 'Failed_TTL',
                resulttime = now()
            WHERE _id IN (
                SELECT _id
                FROM notifications.smsnotifications
                WHERE result = 'Accepted' AND expirytime < now()
                ORDER BY _id DESC
                LIMIT GREATEST(_limit, 1) -- Use the input parameter for the limit
            )
            RETURNING alternateid -- Return all alternateids from updated rows
        )
        -- Select the unique alternateids from the CTE
        SELECT DISTINCT alternateid
        FROM updated_rows;
        
    ELSE
        -- Inform the user if an invalid type was provided. The function will return an empty set.
        RAISE NOTICE 'Invalid notification type: %. Allowed values are ''email'' or ''sms''.', _source;
    END IF;

END;
$$;

-- Add a comment to the function for documentation purposes
COMMENT ON FUNCTION notifications.updateexpirednotifications(TEXT, INT) IS 
'Updates the result of expired email or sms notifications to ''Failed_TTL''. 
Parameters: notification_type (TEXT: ''email'' or ''sms''), update_limit (INT).
Returns a set of unique alternateid for the updated records.';

