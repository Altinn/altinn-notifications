-- This script is autogenerated from the tool DbTools. Do not edit manually.

-- cancelorder.sql:
CREATE OR REPLACE FUNCTION notifications.cancelorder(
    _alternateid uuid,
    _creatorname text
)
RETURNS TABLE(
    cancelallowed boolean,
    alternateid uuid,
    creatorname text,
    sendersreference text,
    created timestamp with time zone,                  
    requestedsendtime timestamp with time zone,
    processed timestamp with time zone,
    processedstatus orderprocessingstate,
    notificationchannel text,
    ignorereservation boolean,
    resourceid text,
    conditionendpoint text,
    generatedemailcount bigint,
    succeededemailcount bigint,
    generatedsmscount bigint, 
    succeededsmscount bigint
) 
LANGUAGE plpgsql
AS $$
DECLARE
    order_record RECORD;
BEGIN
    -- Retrieve the order and its status
    SELECT o.requestedsendtime, o.processedstatus
    INTO order_record
    FROM notifications.orders o
    WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname;

    -- If no order is found, return an empty result set
    IF NOT FOUND THEN
        RETURN;
    END IF;
    
     -- Check if order is already cancelled
     IF order_record.processedstatus = 'Cancelled' THEN
        RETURN QUERY 
        SELECT TRUE AS cancelallowed,
           order_details.*
        FROM notifications.getorder_includestatus_v4(_alternateid, _creatorname) AS order_details;
     ELSIF (order_record.requestedsendtime <= NOW() + INTERVAL '5 minutes' or order_record.processedstatus != 'Registered') THEN
        RETURN QUERY 
        SELECT FALSE AS cancelallowed, NULL::uuid, NULL::text, NULL::text, NULL::timestamp with time zone, NULL::timestamp with time zone, NULL::timestamp with time zone, NULL::orderprocessingstate, NULL::text, NULL::boolean, NULL::text, NULL::text, NULL::bigint, NULL::bigint, NULL::bigint, NULL::bigint;
     ELSE 
        -- Cancel the order by updating its status
        UPDATE notifications.orders o
        SET processedstatus = 'Cancelled', processed = NOW()
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname;

        -- Retrieve the updated order details
        RETURN QUERY 
        SELECT TRUE AS cancelallowed,
               order_details.*
        FROM notifications.getorder_includestatus_v4(_alternateid, _creatorname) AS order_details;
    END IF;      
END;
$$;


-- claimanytimesmsbatch.sql:
-- FUNCTION: notifications.claim_anytime_sms_batch(integer)
CREATE OR REPLACE FUNCTION notifications.claim_anytime_sms_batch (
  _batchsize integer DEFAULT NULL
)
RETURNS TABLE (
  alternateid uuid,
  sendernumber text,
  mobilenumber text,
  body text
)
LANGUAGE plpgsql
VOLATILE
AS $$
DECLARE
  v_batchsize integer := GREATEST(1, COALESCE(_batchsize, 500));
BEGIN
  RETURN QUERY
  WITH claimed_new_rows AS (
    SELECT sms._id, sms._orderid
    FROM notifications.smsnotifications sms
    JOIN notifications.orders ord ON ord._id = sms._orderid
    WHERE sms.result = 'New'::smsnotificationresulttype
      AND sms.expirytime >= now()
      AND ord.sendingtimepolicy = 1
    ORDER BY sms._id
    FOR UPDATE OF sms SKIP LOCKED
    LIMIT v_batchsize
  ),
  updated_rows AS (
    UPDATE notifications.smsnotifications sms
    SET resulttime = now(),
        result = 'Sending'::smsnotificationresulttype
    FROM claimed_new_rows claimed
    WHERE sms._id = claimed._id
    RETURNING
      sms._orderid,
      sms.alternateid,
      sms.mobilenumber,
      sms.customizedbody
  )
  SELECT
    upd.alternateid,
    txt.sendernumber,
    upd.mobilenumber,
    COALESCE(NULLIF(upd.customizedbody, ''), txt.body) AS body
  FROM updated_rows upd
  JOIN notifications.smstexts txt ON txt._orderid = upd._orderid;
END;
$$;

COMMENT ON FUNCTION notifications.claim_anytime_sms_batch(INTEGER) IS
'Claims and returns batches of SMS notifications (sendingtimepolicy = 1).
_batchsize: requested batch size (defaults to 500 if NULL or <1).';

-- claimdaytimesmsbatch.sql:
-- FUNCTION: notifications.claim_daytime_sms_batch(integer)
CREATE OR REPLACE FUNCTION notifications.claim_daytime_sms_batch (
  _batchsize integer DEFAULT NULL
)
RETURNS TABLE (
  alternateid uuid,
  sendernumber text,
  mobilenumber text,
  body text
)
LANGUAGE plpgsql
VOLATILE
AS $$
DECLARE
  v_batchsize integer := GREATEST(1, COALESCE(_batchsize, 500));
BEGIN
  RETURN QUERY
  WITH claimed_new_rows AS (
    SELECT sms._id, sms._orderid
    FROM notifications.smsnotifications sms
    JOIN notifications.orders ord ON ord._id = sms._orderid
    WHERE sms.result = 'New'::smsnotificationresulttype
      AND sms.expirytime >= now()
      AND (ord.sendingtimepolicy = 2 OR ord.sendingtimepolicy IS NULL)
    ORDER BY sms._id
    FOR UPDATE OF sms SKIP LOCKED
    LIMIT v_batchsize
  ),
  updated_rows AS (
    UPDATE notifications.smsnotifications sms
    SET resulttime = now(),
        result = 'Sending'::smsnotificationresulttype
    FROM claimed_new_rows claimed
    WHERE sms._id = claimed._id
    RETURNING
      sms._orderid,
      sms.alternateid,
      sms.mobilenumber,
      sms.customizedbody
  )
  SELECT
    upd.alternateid,
    txt.sendernumber,
    upd.mobilenumber,
    COALESCE(NULLIF(upd.customizedbody, ''), txt.body) AS body
  FROM updated_rows upd
  JOIN notifications.smstexts txt ON txt._orderid = upd._orderid;
END;
$$;

COMMENT ON FUNCTION notifications.claim_daytime_sms_batch(INTEGER) IS
'Claims and returns batches of SMS notifications (sendingtimepolicy = 2 or NULL).
_batchsize: requested batch size (defaults to 500 if NULL or <1).';

-- claimemailbatch.sql:
CREATE OR REPLACE FUNCTION notifications.claim_email_batch(
    _batchsize integer DEFAULT NULL::integer)
    RETURNS TABLE(alternateid uuid, subject text, body text, fromaddress text, toaddress text, contenttype text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    v_batchsize integer := GREATEST(1, COALESCE(_batchsize, 500));
    latest_email_timeout timestamp;
    v_limitlog_id integer;
BEGIN
    SELECT id, emaillimittimeout
    INTO v_limitlog_id, latest_email_timeout
    FROM notifications.resourcelimitlog
    WHERE id = (SELECT MAX(id) FROM notifications.resourcelimitlog)
    FOR UPDATE SKIP LOCKED;
    
    -- Check if lock is taken
    IF v_limitlog_id IS NULL THEN
        RETURN QUERY 
        SELECT NULL::uuid AS alternateid, 
               NULL::text AS subject, 
               NULL::text AS body, 
               NULL::text AS fromaddress, 
               NULL::text AS toaddress, 
               NULL::text AS contenttype 
        WHERE FALSE;
        RETURN;
    END IF;

    -- Check if there's an active email timeout
    IF latest_email_timeout IS NOT NULL AND latest_email_timeout > now() THEN
        RETURN QUERY 
        SELECT NULL::uuid AS alternateid, 
               NULL::text AS subject, 
               NULL::text AS body, 
               NULL::text AS fromaddress, 
               NULL::text AS toaddress, 
               NULL::text AS contenttype 
        WHERE FALSE;
        RETURN;
    END IF;

    -- Clear expired timeout
    UPDATE notifications.resourcelimitlog
    SET emaillimittimeout = NULL
    WHERE id = v_limitlog_id
        AND emaillimittimeout IS NOT NULL 
        AND emaillimittimeout <= now();

    RETURN QUERY
    WITH claimed_new_rows AS (
        SELECT 
            email._id, 
            email._orderid,
            email.alternateid,
            email.toaddress
        FROM notifications.emailnotifications email
        WHERE email.result = 'New'::emailnotificationresulttype
            AND email.expirytime >= now()
        ORDER BY email._id
        FOR UPDATE OF email SKIP LOCKED
        LIMIT v_batchsize
    ),
    updated_rows AS (
        UPDATE notifications.emailnotifications email
        SET resulttime = now(),
            result = 'Sending'::emailnotificationresulttype
        FROM claimed_new_rows claimed
        WHERE email._id = claimed._id
        RETURNING
            claimed.alternateid,
            claimed._orderid,
            claimed.toaddress
    )
    -- Join with large text data AFTER releasing locks
    SELECT 
        updated.alternateid,
        txt.subject,
        txt.body,
        txt.fromaddress,
        updated.toaddress,
        txt.contenttype
    FROM updated_rows updated
    JOIN notifications.emailtexts txt ON txt._orderid = updated._orderid;
END;
$BODY$;

ALTER FUNCTION notifications.claim_email_batch(integer)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.claim_email_batch(integer)
    IS 'Claims and returns batches of email notifications.
_batchsize: requested batch size (defaults to 500 if NULL or <1).';


-- deleteoldstatusfeedrecords.sql:
-- Creates or replaces a function to delete statusfeed records older than 90 days
CREATE OR REPLACE FUNCTION notifications.delete_old_status_feed_records()
RETURNS bigint -- Returns the number of rows deleted
LANGUAGE 'plpgsql'
VOLATILE
AS $$
DECLARE
    -- Variable to hold the count of deleted rows
    deleted_count bigint := 0;
    -- Variable to hold the lock acquisition status
    lock_acquired boolean;
    -- Generate lock ID from function name using hashtext
    lock_id bigint := hashtext('notifications.delete_old_status_feed_records');
BEGIN
    -- Acquire a advisory lock to prevent concurrent cleanup operations
    SELECT pg_try_advisory_lock(lock_id) INTO lock_acquired;
    
    IF NOT lock_acquired THEN
        RETURN 0; -- Another cleanup is running
    END IF;
    
    WITH deleted_rows AS (
        DELETE FROM notifications.statusfeed 
        WHERE created <= NOW() - INTERVAL '90 days'
        RETURNING _id
    )
    -- Count the rows that were captured in the CTE
    SELECT count(*) INTO deleted_count FROM deleted_rows;
    
    PERFORM pg_advisory_unlock(lock_id);
    
    RETURN deleted_count;
END;
$$;

-- Add a comment to describe the function's purpose
COMMENT ON FUNCTION notifications.delete_old_status_feed_records() IS
'Deletes records from notifications.statusfeed where the "created" timestamp is 90 days or older. Returns the count of deleted records. Uses an advisory lock to prevent concurrent executions.';


-- deleteoldtestdata.sql:
-- FUNCTION: notifications.delete_old_test_data()

-- DROP FUNCTION IF EXISTS notifications.delete_old_test_data();

CREATE OR REPLACE FUNCTION notifications.delete_old_test_data()
RETURNS void
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    deleted_count INTEGER := 0;
BEGIN
    -- Delete for orders
    DELETE FROM notifications.orders
    WHERE creatorname = 'ttd' 
    AND requestedsendtime < NOW() - INTERVAL '90 days'
    AND (
        notificationorder -> 'Recipients' -> 0 -> 'AddressInfo' -> 0 ->> 'MobileNumber' IN ('+4799999999', '+4792395437')
        OR notificationorder -> 'Recipients' -> 0 -> 'AddressInfo' -> 0 ->> 'EmailAddress' = 'wvjckqug@sharklasers.com'
        OR notificationorder -> 'Recipients' -> 0 ->> 'OrganizationNumber' IN ('910026623', '910058789', '810889802')
    );
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RAISE NOTICE 'Deleted % old test orders', deleted_count;

    -- Delete for orderschain
    DELETE FROM notifications.orderschain
    WHERE creatorname = 'ttd' 
    AND created < NOW() - INTERVAL '90 days'
    AND (
        orderchain -> 'Recipient' -> 'RecipientOrganization' ->> 'OrgNumber' IN ('910058789', '910026623', '810889802')
        OR orderchain -> 'Recipient' -> 'RecipientSms' ->> 'PhoneNumber' IN ('+4799999999', '+4792395437')
        OR orderchain -> 'Recipient' -> 'RecipientEmail' ->> 'EmailAddress' = 'wvjckqug@sharklasers.com'
    );
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RAISE NOTICE 'Deleted % old test order chains', deleted_count;
END;
$BODY$;

ALTER FUNCTION notifications.delete_old_test_data()
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.delete_old_test_data()
    IS 'This function performs cleanup of test-specific data based on hard-coded criteria used in use case tests. 
	It removes records from notifications.orders, notifications.emailnotifications (cascading delete), and notifications.smsnotifications (cascading delete), 
	using email addresses, mobile numbers, and synthetic organizations used only for testing. This ensures test data does not accumulate.';


-- getemailrecipients.sql:
CREATE OR REPLACE FUNCTION notifications.getemailrecipients_v2(_alternateid uuid)
RETURNS TABLE(
    recipientorgno text, 
    recipientnin text, 
    toaddress text
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
__orderid BIGINT := (SELECT _id from notifications.orders
			where alternateid = _alternateid);
BEGIN
RETURN query 
	SELECT e.recipientorgno, e.recipientnin, e.toaddress
	FROM notifications.emailnotifications e
	WHERE e._orderid = __orderid;
END;
$BODY$;

-- getemailsstatusnewupdatestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getemails_statusnew_updatestatus()
    RETURNS TABLE(alternateid uuid, subject text, body text, fromaddress text, toaddress text, contenttype text) 
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    latest_email_timeout TIMESTAMP WITH TIME ZONE;
BEGIN
    SELECT emaillimittimeout 
    INTO latest_email_timeout 
    FROM notifications.resourcelimitlog 
    WHERE id = (SELECT MAX(id) FROM notifications.resourcelimitlog);

    -- Check if the latest email timeout is set and valid
    IF latest_email_timeout IS NOT NULL THEN
        IF latest_email_timeout >= NOW() THEN
            RETURN QUERY 
            SELECT NULL::uuid AS alternateid, 
                   NULL::text AS subject, 
                   NULL::text AS body, 
                   NULL::text AS fromaddress, 
                   NULL::text AS toaddress, 
                   NULL::text AS contenttype 
            WHERE FALSE;
            RETURN;
        ELSE 
            UPDATE notifications.resourcelimitlog 
            SET emaillimittimeout = NULL 
            WHERE id = (SELECT MAX(id) FROM notifications.resourcelimitlog);
        END IF;
    END IF;
    
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.emailnotifications
        SET result = 'Sending', resulttime = now()
        WHERE result = 'New' 
        RETURNING notifications.emailnotifications.alternateid, 
                  _orderid, 
                  notifications.emailnotifications.toaddress, 
                  notifications.emailnotifications.customizedsubject, 
                  notifications.emailnotifications.customizedbody
    )
    SELECT u.alternateid, 
           CASE WHEN u.customizedsubject IS NOT NULL AND u.customizedsubject <> '' THEN u.customizedsubject ELSE et.subject END AS subject, 
           CASE WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' THEN u.customizedbody ELSE et.body END AS body, 
           et.fromaddress, 
           u.toaddress, 
           et.contenttype 
    FROM updated u
    JOIN notifications.emailtexts et ON u._orderid = et._orderid;    
END;
$BODY$;


-- getemailsummary.sql:
CREATE OR REPLACE FUNCTION notifications.getemailsummary_v2(
	_alternateorderid uuid,
	_creatorname text)
    RETURNS TABLE(
        sendersreference text, 
        alternateid uuid, 
        recipientorgno text, 
        recipientnin text, 
        toaddress text, 
        result emailnotificationresulttype, 
        resulttime timestamptz) 
    LANGUAGE 'plpgsql'
AS $BODY$

	BEGIN
		RETURN QUERY
		   SELECT o.sendersreference, n.alternateid, n.recipientorgno, n.recipientnin, n.toaddress, n.result, n.resulttime
			FROM notifications.emailnotifications n
            LEFT JOIN notifications.orders o ON n._orderid = o._id
			WHERE o.alternateid = _alternateorderid
			and o.creatorname = _creatorname;
        IF NOT FOUND THEN
            RETURN QUERY
            SELECT o.sendersreference, NULL::uuid, NULL::text, NULL::text, NULL::text, NULL::emailnotificationresulttype, NULL::timestamptz
            FROM notifications.orders o
            WHERE o.alternateid = _alternateorderid
            and o.creatorname = _creatorname;
        END IF;
	END;
$BODY$;

-- getinstantordertracking.sql:
CREATE OR REPLACE FUNCTION notifications.get_instant_order_tracking
(
    _creatorname text,
    _idempotencyid text
)
RETURNS TABLE (
    orders_chain_id uuid,
    shipment_id uuid,
    senders_reference text
) 
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        oc.orderid AS orders_chain_id,
        (oc.orderchain->>'OrderId')::uuid AS shipment_id,
        oc.orderchain->>'SendersReference' AS senders_reference
    FROM 
        notifications.orderschain oc
    WHERE 
        oc.creatorname = _creatorname
        AND oc.idempotencyid = _idempotencyid
        AND oc.orderchain->>'Type' = '2';
END;
$$;

COMMENT ON FUNCTION notifications.get_instant_order_tracking IS 
'Retrieves tracking information for an instant notification order using the creator''s short name and idempotency identifier.
This function provides a streamlined version of order tracking specifically for instant notifications,
enabling idempotent operations by allowing clients to retrieve previously submitted
notification information without creating duplicates.
Parameters:
- _creatorname: The short name of the creator that originally submitted the notification order
- _idempotencyid: The idempotency identifier that was defined when the order was created
Returns a table with the following columns:
- orders_chain_id: The unique identifier for the notification order in the system
- shipment_id: The unique identifier for the notification shipment
- senders_reference: The sender''s reference for the notification (may be null)';

-- getmetrics.sql:
CREATE OR REPLACE FUNCTION notifications.getmetrics(
    month_input int,
    year_input int
)
RETURNS TABLE (
    org text,
    placed_orders bigint,
    sent_emails bigint,
    succeeded_emails bigint,
    sent_sms bigint,
    succeeded_sms bigint
)
AS $$
BEGIN
    RETURN QUERY
    SELECT
        o.creatorname,
        COUNT(DISTINCT o._id) AS placed_orders,
        SUM(CASE WHEN e._id IS NOT NULL THEN 1 ELSE 0 END) AS sent_emails,
        SUM(CASE WHEN e.result IN ('Delivered', 'Succeeded') THEN 1 ELSE 0 END) AS succeeded_emails, 
        SUM(CASE WHEN s._id IS NOT NULL THEN s.smscount ELSE 0 END) AS sent_sms,
        SUM(CASE WHEN s.result = 'Accepted' THEN 1 ELSE 0 END) AS succeeded_sms
    FROM notifications.orders o
    LEFT JOIN notifications.emailnotifications e ON o._id = e._orderid
    LEFT JOIN notifications.smsnotifications s ON o._id = s._orderid
    WHERE EXTRACT(MONTH FROM o.requestedsendtime) = month_input
        AND EXTRACT(YEAR FROM o.requestedsendtime) = year_input
    GROUP BY o.creatorname;
END;
$$ LANGUAGE plpgsql;

-- FUNCTION: notifications.get_metrics_v2(integer, integer)
CREATE OR REPLACE FUNCTION notifications.get_metrics_v2(
	month_input integer,
	year_input integer)
    RETURNS TABLE(org text, placed_orders bigint, sent_emails bigint, succeeded_emails bigint, sent_sms bigint, succeeded_sms bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    STABLE PARALLEL SAFE
    ROWS 1000

AS $BODY$
DECLARE
  start_date DATE;
BEGIN
  start_date = MAKE_DATE(year_input, month_input, 1);

  RETURN QUERY
    WITH filtered_orders AS (
		SELECT o._id, o.creatorname
		FROM Notifications.orders o
		WHERE o.requestedsendtime >= start_date
			AND o.requestedsendtime < start_date + INTERVAL '1 month'
	),
    email_per_order AS (
        SELECT
            e._orderid,
            COUNT(e._id)::bigint AS sent_emails,
            COALESCE(SUM(CASE WHEN e.result IN ('Delivered', 'Succeeded') THEN 1 ELSE 0 END), 0)::bigint AS succeeded_emails
        FROM notifications.emailnotifications e
		JOIN filtered_orders fo ON fo._id = e._orderid
        GROUP BY e._orderid
    ),
    sms_per_order AS (
        SELECT
            s._orderid,
            COALESCE(SUM(s.smscount), 0)::bigint AS sent_sms,
            COALESCE(SUM(CASE WHEN s.result IN ('Delivered', 'Accepted') THEN 1 ELSE 0 END), 0)::bigint AS succeeded_sms
        FROM notifications.smsnotifications s
		JOIN filtered_orders fo ON fo._id = s._orderid
        GROUP BY s._orderid
    )
    SELECT
        fo.creatorname AS org,
        COUNT(fo._id) AS placed_orders,
        COALESCE(SUM(eo.sent_emails), 0)::bigint AS sent_emails,
        COALESCE(SUM(eo.succeeded_emails), 0)::bigint AS succeeded_emails,
        COALESCE(SUM(so.sent_sms), 0)::bigint AS sent_sms,
        COALESCE(SUM(so.succeeded_sms), 0)::bigint AS succeeded_sms
    FROM filtered_orders fo
    LEFT JOIN email_per_order eo ON eo._orderid = fo._id
    LEFT JOIN sms_per_order so ON so._orderid = fo._id
    GROUP BY fo.creatorname;
   
END;
$BODY$;

ALTER FUNCTION notifications.get_metrics_v2(integer, integer)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.get_metrics_v2(integer, integer) IS 
'This function aggregates data by creator name, returning the total order count and the sum of notifications sent, as well as with a successful status (Succeeded or Delivered for emails, Accepted or Delivered for SMS).';


-- getorderincludestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getorder_includestatus_v4(
    _alternateid uuid,
    _creatorname text
)
RETURNS TABLE(
    alternateid uuid,
    creatorname text,
    sendersreference text,
    created timestamp with time zone,                  
    requestedsendtime timestamp with time zone,
    processed timestamp with time zone,
    processedstatus orderprocessingstate,
    notificationchannel text,
    ignorereservation boolean,
    resourceid text,
    conditionendpoint text,
    generatedemailcount bigint,
    succeededemailcount bigint,
    generatedsmscount bigint, 
    succeededsmscount bigint
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    _target_orderid INTEGER;
    _succeededEmailCount BIGINT;
    _generatedEmailCount BIGINT;
    _succeededSmsCount BIGINT;
    _generatedSmsCount BIGINT;
BEGIN
    SELECT _id INTO _target_orderid 
    FROM notifications.orders
    WHERE orders.alternateid = _alternateid 
    AND orders.creatorname = _creatorname;
    
    SELECT
        SUM(CASE WHEN result IN ('Delivered', 'Succeeded') THEN 1 ELSE 0 END), 
        COUNT(1) AS generatedEmailCount
    INTO _succeededEmailCount, _generatedEmailCount
    FROM notifications.emailnotifications
    WHERE emailnotifications._orderid = _target_orderid;
    
    SELECT      
        SUM(CASE WHEN result = 'Accepted' THEN 1 ELSE 0 END), 
        COUNT(1) AS generatedSmsCount
    INTO _succeededSmsCount, _generatedSmsCount
    FROM notifications.smsnotifications
    WHERE smsnotifications._orderid = _target_orderid;

    RETURN QUERY
    SELECT 
        orders.alternateid,
        orders.creatorname,
        orders.sendersreference,
        orders.created,
        orders.requestedsendtime,
        orders.processed,
        orders.processedstatus,
        orders.notificationorder->>'NotificationChannel',
        CASE 
            WHEN orders.notificationorder->>'IgnoreReservation' IS NULL THEN NULL
            ELSE (orders.notificationorder->>'IgnoreReservation')::BOOLEAN
        END AS IgnoreReservation,
        orders.notificationorder->>'ResourceId',
        orders.notificationorder->>'ConditionEndpoint',
        _generatedEmailCount,
        _succeededEmailCount,
        _generatedSmsCount, 
        _succeededSmsCount
    FROM
        notifications.orders AS orders
    WHERE 
        orders._id = _target_orderid;
END;
$BODY$;


-- getorderschaintracking.sql:
-- Retrieves tracking information for a notification order chain using the creator's short name and idempotency identifier.
CREATE OR REPLACE FUNCTION notifications.get_orders_chain_tracking
(
    _creatorname text,
    _idempotencyid text
)
RETURNS TABLE (
    orders_chain_id uuid,
    shipment_id uuid,
    senders_reference text,
    reminders jsonb
) 
LANGUAGE 'plpgsql'
STABLE
AS $BODY$
DECLARE
    v_record_exists boolean;
BEGIN
    -- Check if record exists first to provide better error handling
    SELECT EXISTS (
        SELECT 1 
        FROM notifications.orderschain 
        WHERE creatorname = _creatorname
        AND idempotencyid = _idempotencyid
        -- exclude type 'Instant' from results
		AND (orderchain->>'Type' <> '2' OR orderchain->>'Type' IS NULL) 
    ) INTO v_record_exists;
    
    IF NOT v_record_exists THEN
        -- Return empty result set with no rows
        RETURN;
    END IF;

    RETURN QUERY
    SELECT 
        orders_chain.orderid AS orders_chain_id,
        (orders_chain.orderchain->>'OrderId')::uuid AS shipment_id,
        orders_chain.orderchain->>'SendersReference' AS senders_reference,
        -- Extract only OrderId and SendersReference from each reminder
        COALESCE(
            (SELECT jsonb_agg(
                jsonb_build_object(
                    'ShipmentId', reminder->>'OrderId',
                    'SendersReference', reminder->>'SendersReference'
                )
            )
            FROM jsonb_array_elements(
                CASE 
                    WHEN jsonb_typeof(orders_chain.orderchain->'Reminders') = 'array' AND 
                         (orders_chain.orderchain->'Reminders') IS NOT NULL AND
                         (orders_chain.orderchain->'Reminders') <> 'null'::jsonb
                    THEN orders_chain.orderchain->'Reminders'
                    ELSE '[]'::jsonb
                END
            ) AS reminder),
            '[]'::jsonb
        ) AS reminders
    FROM 
        notifications.orderschain orders_chain
    WHERE 
        orders_chain.creatorname = _creatorname
        AND orders_chain.idempotencyid = _idempotencyid
        -- Exclude type 'Instant' from results
        AND (orders_chain.orderchain->>'Type' <> '2' OR orders_chain.orderchain->>'Type' IS NULL);
END;
$BODY$;

COMMENT ON FUNCTION notifications.get_orders_chain_tracking IS 
'Retrieves tracking information for a notification order chain using the creator''s short name and idempotency identifier.

This function enables idempotent operations by allowing clients to retrieve previously submitted
notification chain information without creating duplicates. It specifically excludes order chains where the type is ''Instant'' (i.e., where the ''Type'' field in the orderchain data is ''2'').

Parameters:
- _creatorname: The short name of the creator that originally submitted the notification order chain
- _idempotencyid: The idempotency identifier that was defined when the order chain was created

Returns a table with the following columns:
- orders_chain_id: The unique identifier for the entire notification order chain
- shipment_id: The unique identifier for the main notification order
- senders_reference: The sender''s reference for the main notification order (may be null)
- reminders: A JSON array containing tracking information for any reminder notifications

The reminders JSON array contains objects with the following structure:
- OrderId: The unique identifier for the reminder notification order
- SendersReference: The sender''s reference for the reminder notification (may be null).';


-- getorderspastsendtimeupdatestatus.sql:
CREATE OR REPLACE FUNCTION notifications.getorders_pastsendtime_updatestatus()
    RETURNS TABLE(notificationorders jsonb)
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY
    WITH claimed_orders AS (
        SELECT _id
        FROM notifications.orders
        WHERE processedstatus = 'Registered'::orderprocessingstate
          AND requestedsendtime <= now() + INTERVAL '1 minute'
        ORDER BY requestedsendtime ASC, _id ASC
        LIMIT 50
        FOR UPDATE SKIP LOCKED
    )
    UPDATE notifications.orders
    SET processedstatus = 'Processing'::orderprocessingstate
    WHERE _id IN (SELECT _id FROM claimed_orders)
    RETURNING notificationorder AS notificationorders;
END;
$BODY$;

-- Add comment to document the function's purpose and behavior
COMMENT ON FUNCTION notifications.getorders_pastsendtime_updatestatus() IS
'Retrieves and updates notification orders that are ready for processing.
Selects up to 50 orders with:
- processedstatus = ''Registered''
- requestedsendtime <= current time + 1 minute grace period

Orders are processed in chronological order (oldest first) and status is updated to ''Processing''.
Uses row-level locking with SKIP LOCKED to handle concurrent executions safely - multiple 
instances can run simultaneously without conflicts, each processing different orders.

Returns: JSONB notification order data for the claimed and updated orders.';


-- getshipmentforstatusfeed.sql:
CREATE OR REPLACE FUNCTION notifications.getshipmentforstatusfeed(_alternateid uuid)
RETURNS TABLE(
    alternateid uuid,
    reference text,
    status text,
    last_update timestamp with time zone,
    destination text,
    type text
)
LANGUAGE 'plpgsql'
COST 100
VOLATILE PARALLEL UNSAFE
ROWS 1000
AS $BODY$
BEGIN
    RETURN QUERY
    WITH distinct_orders AS (
        SELECT DISTINCT ON (o._id) o.*
        FROM notifications.orders o
        LEFT JOIN notifications.emailnotifications e ON e._orderid = o._id
        LEFT JOIN notifications.smsnotifications s ON s._orderid = o._id
        WHERE e.alternateid = _alternateid OR s.alternateid = _alternateid
    )
    SELECT
        o.alternateid,
        t.reference,      
        t.status,
        t.last_update,
        t.destination,
        t.type
    FROM
        distinct_orders o
        CROSS JOIN LATERAL notifications.get_shipment_tracking_v2(o.alternateid, o.creatorname) AS t;

END;
$BODY$;

ALTER FUNCTION notifications.getshipmentforstatusfeed(uuid)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.getshipmentforstatusfeed(uuid)
    IS 'Retrieves combined order and shipment tracking data based on an email or sms notification alternateid.';


CREATE OR REPLACE FUNCTION notifications.getshipmentforstatusfeed_v2(_alternateid uuid)
RETURNS TABLE(
    alternateid uuid,
    reference text,
    status text,
    last_update timestamp with time zone,
    destination text,
    type text
)
LANGUAGE 'plpgsql'
COST 100
VOLATILE PARALLEL UNSAFE
ROWS 1000
AS $BODY$
DECLARE
    _order_alternateid uuid;
    _order_creatorname text;
BEGIN
    -- First try to find order information in the email notifications table
    SELECT o.alternateid, o.creatorname INTO _order_alternateid, _order_creatorname
    FROM notifications.orders o
    JOIN notifications.emailnotifications e ON e._orderid = o._id
    WHERE e.alternateid = _alternateid
    LIMIT 1;
    
    -- If not found in email notifications, try SMS notifications table
    IF _order_alternateid IS NULL THEN
        SELECT o.alternateid, o.creatorname INTO _order_alternateid, _order_creatorname
        FROM notifications.orders o
        JOIN notifications.smsnotifications s ON s._orderid = o._id
        WHERE s.alternateid = _alternateid
        LIMIT 1;
    END IF;
    
    -- If we found an order, get its tracking information
    IF _order_alternateid IS NOT NULL THEN
        RETURN QUERY
        SELECT
            _order_alternateid,
            t.reference,        
            t.status,
            t.last_update,
            t.destination,
            t.type
        FROM
            notifications.get_shipment_tracking_v2(_order_alternateid, _order_creatorname) AS t;
    END IF;
END;
$BODY$;

ALTER FUNCTION notifications.getshipmentforstatusfeed_v2(uuid)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.getshipmentforstatusfeed_v2(uuid)
    IS 'Retrieves shipment tracking data using an email or sms notification alternateid.';


CREATE OR REPLACE FUNCTION notifications.getshipmentforstatusfeed_v3(_alternateid uuid)
RETURNS TABLE(
    alternateid       uuid,
    reference         text,
    status            text,
    last_update       timestamp with time zone,
    destination       text,
    type              text,
    notification_type text
)
LANGUAGE 'plpgsql'
COST 100
STABLE PARALLEL SAFE
ROWS 5
AS $BODY$
DECLARE
    _order_alternateid uuid;
    _order_creatorname text;
BEGIN
    -- First try to find order information in the email notifications table
    SELECT o.alternateid, o.creatorname INTO _order_alternateid, _order_creatorname
    FROM notifications.orders o
    JOIN notifications.emailnotifications e ON e._orderid = o._id
    WHERE e.alternateid = _alternateid
    LIMIT 1;
    
    -- If not found in email notifications, try SMS notifications table
    IF _order_alternateid IS NULL THEN
        SELECT o.alternateid, o.creatorname INTO _order_alternateid, _order_creatorname
        FROM notifications.orders o
        JOIN notifications.smsnotifications s ON s._orderid = o._id
        WHERE s.alternateid = _alternateid
        LIMIT 1;
    END IF;
    
    -- If we found an order, get its tracking information
    IF _order_alternateid IS NOT NULL THEN
        RETURN QUERY
        SELECT
            _order_alternateid,
            t.reference,        
            t.status,
            t.last_update,
            t.destination,
            t.type,
            t.notification_type 
        FROM
            notifications.get_shipment_tracking_v3(_order_alternateid, _order_creatorname) AS t;
    END IF;
END;
$BODY$;

ALTER FUNCTION notifications.getshipmentforstatusfeed_v3(uuid)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.getshipmentforstatusfeed_v3(uuid)
    IS 'Retrieves shipment tracking data using an email or sms notification alternateid.';


-- getshipmenttracking.sql:
CREATE OR REPLACE FUNCTION notifications.get_shipment_tracking(
    _alternateid UUID,
    _creatorname TEXT)
RETURNS TABLE (
    reference     TEXT,
    status        TEXT,
    last_update   TIMESTAMPTZ,
    destination   TEXT
) AS $$
DECLARE
    v_order_exists BOOLEAN;
BEGIN
    -- Check for the existence of the order
    SELECT EXISTS (
        SELECT 1
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    )
    INTO v_order_exists;

    -- Return empty set if no order is found
    IF NOT v_order_exists THEN
        RETURN;
    END IF;

    -- Return combined tracking info
    RETURN QUERY
    WITH order_data AS (
        SELECT o._id, o.sendersreference, o.created, o.processed, o.processedstatus
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    ),
    order_tracking AS (
        SELECT
            od.sendersreference AS reference,
            od.processedstatus::TEXT AS status,
            GREATEST(od.created, COALESCE(od.processed, od.created)) AS last_update,
            NULL::TEXT AS destination
        FROM order_data od
    ),
    email_tracking AS (
        SELECT
            od.sendersreference AS reference,
            e.result::TEXT AS status,
            e.resulttime AS last_update,
            e.toaddress AS destination
        FROM order_data od
        JOIN notifications.emailnotifications e ON e._orderid = od._id
    ),
    sms_tracking AS (
        SELECT
            od.sendersreference AS reference,
            s.result::TEXT AS status,
            s.resulttime AS last_update,
            s.mobilenumber AS destination
        FROM order_data od
        JOIN notifications.smsnotifications s ON s._orderid = od._id
    )
    SELECT * FROM order_tracking
    UNION ALL
    SELECT * FROM email_tracking
    UNION ALL
    SELECT * FROM sms_tracking;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.get_shipment_tracking(UUID, TEXT) IS
'Returns delivery tracking information for a notification identified by the given alternate identifier and creator name.

Includes:
 - Order-level tracking (reference and status)
 - Email notification tracking (status, result time, destination)
 - SMS notification tracking (status, result time, destination)

If no matching order exists, an empty result set is returned.';


-- This is a new version to return the type of the notification
CREATE OR REPLACE FUNCTION notifications.get_shipment_tracking_v2(
    _alternateid UUID,
    _creatorname TEXT)
RETURNS TABLE (
    reference     TEXT,
    status        TEXT,
    last_update   TIMESTAMPTZ,
    destination   TEXT,
    type          TEXT
) AS $$
DECLARE
    v_order_exists BOOLEAN;
BEGIN
    -- Check for the existence of the order
    SELECT EXISTS (
        SELECT 1
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    )
    INTO v_order_exists;

    -- Return empty set if no order is found
    IF NOT v_order_exists THEN
        RETURN;
    END IF;

    -- Return combined tracking info
    RETURN QUERY
    WITH order_data AS (
        SELECT o._id, o.sendersreference, o.created, o.processed, o.processedstatus, o.type
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    ),
    order_tracking AS (
        SELECT
            od.sendersreference AS reference,
            od.processedstatus::TEXT AS status,
            GREATEST(od.created, COALESCE(od.processed, od.created)) AS last_update,
            NULL::TEXT AS destination,
            od.type::TEXT AS type
        FROM order_data od
    ),
    email_tracking AS (
        SELECT
            od.sendersreference AS reference,
            e.result::TEXT AS status,
            e.resulttime AS last_update,
            e.toaddress AS destination,
            od.type::TEXT AS type
        FROM order_data od
        JOIN notifications.emailnotifications e ON e._orderid = od._id
    ),
    sms_tracking AS (
        SELECT
            od.sendersreference AS reference,
            s.result::TEXT AS status,
            s.resulttime AS last_update,
            s.mobilenumber AS destination,
            od.type::TEXT AS type
        FROM order_data od
        JOIN notifications.smsnotifications s ON s._orderid = od._id
    )
    SELECT * FROM order_tracking
    UNION ALL
    SELECT * FROM email_tracking
    UNION ALL
    SELECT * FROM sms_tracking;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.get_shipment_tracking_v2(UUID, TEXT) IS
'Returns delivery tracking information for a notification identified by the given alternate identifier and creator name.

Includes:
 - Order-level tracking (reference and status)
 - Email notification tracking (status, result time, destination)
 - SMS notification tracking (status, result time, destination)

If no matching order exists, an empty result set is returned.';

CREATE OR REPLACE FUNCTION notifications.get_shipment_tracking_v3(
    _alternateid UUID,
    _creatorname TEXT)
RETURNS TABLE (
    reference          TEXT,
    status             TEXT,
    last_update        TIMESTAMPTZ,
    destination        TEXT,
    type               TEXT,
    notification_type  TEXT
)
LANGUAGE plpgsql
STABLE PARALLEL SAFE
ROWS 5
AS $$
DECLARE
    v_order_exists BOOLEAN;
BEGIN
    -- Check for the existence of the order
    SELECT EXISTS (
        SELECT 1
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    )
    INTO v_order_exists;

    -- Return empty set if no order is found
    IF NOT v_order_exists THEN
        RETURN;
    END IF;

    -- Return combined tracking info
    RETURN QUERY
    WITH order_data AS (
        SELECT o._id, o.sendersreference, o.created, o.processed, o.processedstatus, o.type
        FROM notifications.orders o
        WHERE o.alternateid = _alternateid AND o.creatorname = _creatorname
    ),
    order_tracking AS (
        SELECT
            od.sendersreference AS reference,
            od.processedstatus::TEXT AS status,
            GREATEST(od.created, COALESCE(od.processed, od.created)) AS last_update,
            NULL::TEXT AS destination,
            od.type::TEXT AS type,
            'order' AS notification_type
        FROM order_data od
    ),
    email_tracking AS (
        SELECT
            od.sendersreference AS reference,
            e.result::TEXT AS status,
            e.resulttime AS last_update,
            e.toaddress AS destination,
            od.type::TEXT AS type,
            'email' AS notification_type
        FROM order_data od
        JOIN notifications.emailnotifications e ON e._orderid = od._id
    ),
    sms_tracking AS (
        SELECT
            od.sendersreference AS reference,
            s.result::TEXT AS status,
            s.resulttime AS last_update,
            s.mobilenumber AS destination,
            od.type::TEXT AS type,
            'sms' AS notification_type
        FROM order_data od
        JOIN notifications.smsnotifications s ON s._orderid = od._id
    )
    SELECT * FROM order_tracking
    UNION ALL
    SELECT * FROM email_tracking
    UNION ALL
    SELECT * FROM sms_tracking;
END;
$$;

COMMENT ON FUNCTION notifications.get_shipment_tracking_v3(UUID, TEXT) IS
'Returns delivery tracking information for a notification identified by the given alternate identifier and creator name.

Includes:
 - Order-level tracking (reference and status)
 - Email notification tracking (status, result time, destination)
 - SMS notification tracking (status, result time, destination)

Changes from v2:
 - Added notification_type field to distinguish between order, email, and sms tracking records
 - notification_type values: ''order'', ''email'', ''sms''

If no matching order exists, an empty result set is returned.';


-- getsmsrecipients.sql:
CREATE OR REPLACE FUNCTION notifications.getsmsrecipients_v2(_orderid uuid)
RETURNS TABLE(
  recipientorgno text, 
  recipientnin text,
  mobilenumber text
) 
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
__orderid BIGINT := (SELECT _id from notifications.orders
			where alternateid = _orderid);
BEGIN
RETURN query 
	SELECT s.recipientorgno, s.recipientnin, s.mobilenumber
	FROM notifications.smsnotifications s
	WHERE s._orderid = __orderid;
END;
$BODY$;

-- getsmsstatusnewupdatestatus.sql:
-- This function is kept for backward compatibility and may be removed in future versions.
-- Use notifications.getsms_statusnew_updatestatus(integer) instead.
CREATE OR REPLACE FUNCTION notifications.getsms_statusnew_updatestatus()
    RETURNS TABLE(alternateid uuid, sendernumber text, mobilenumber text, body text) 
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.smsnotifications
        SET result = 'Sending', resulttime = now()
        WHERE result = 'New' 
        RETURNING notifications.smsnotifications.alternateid, 
                  _orderid, 
                  notifications.smsnotifications.mobilenumber,
                  notifications.smsnotifications.customizedbody
    )
    SELECT u.alternateid, 
           st.sendernumber, 
           u.mobilenumber, 
           CASE WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' THEN u.customizedbody ELSE st.body END AS body
    FROM updated u
    JOIN notifications.smstexts st ON u._orderid = st._orderid;        
END;
$BODY$;

-- FUNCTION: notifications.getsms_statusnew_updatestatus(integer)
CREATE OR REPLACE FUNCTION NOTIFICATIONS.GETSMS_STATUSNEW_UPDATESTATUS (_SENDINGTIMEPOLICY INTEGER) 
RETURNS TABLE (
    ALTERNATEID UUID,
    SENDERNUMBER TEXT,
    MOBILENUMBER TEXT,
    BODY TEXT
) 
LANGUAGE 'plpgsql' 
COST 100 
VOLATILE 
PARALLEL UNSAFE 
ROWS 1000 
AS $BODY$
BEGIN
    RETURN QUERY 
    WITH updated AS (
        UPDATE notifications.smsnotifications s
        SET result = 'Sending', resulttime = now()
        FROM notifications.orders o
        WHERE s.result = 'New' 
          AND s._orderid = o._id
          AND (
              (_sendingtimepolicy = 1 AND o.sendingtimepolicy = 1)
           OR (_sendingtimepolicy = 2 AND (o.sendingtimepolicy = 2 OR o.sendingtimepolicy IS NULL))
          )
        RETURNING s.alternateid, 
                  s._orderid, 
                  s.mobilenumber,
                  s.customizedbody
    )
    SELECT u.alternateid, 
           st.sendernumber, 
           u.mobilenumber, 
           CASE 
               WHEN u.customizedbody IS NOT NULL AND u.customizedbody <> '' 
               THEN u.customizedbody 
               ELSE st.body 
           END AS body
    FROM updated u
    JOIN notifications.smstexts st ON u._orderid = st._orderid;
END;
$BODY$;

COMMENT ON FUNCTION NOTIFICATIONS.GETSMS_STATUSNEW_UPDATESTATUS (INTEGER) IS 'Reads all entries in smsnotifications where result status is New.
 Result is then updated to Sending. Parameter _sendingtimepolicy is used to
 filter the returned entries based on the policy for scheduling set on the related
 order row. If this is null, it is treated as Daytime, which is the default setting';

-- getsmssummary.sql:
CREATE OR REPLACE FUNCTION notifications.getsmssummary_v2(
	_alternateorderid uuid,
	_creatorname text)
    RETURNS TABLE(
        sendersreference text, 
        alternateid uuid, 
        recipientorgno text, 
        recipientnin text, 
        mobilenumber text, 
        result smsnotificationresulttype, 
        resulttime timestamptz) 
    LANGUAGE 'plpgsql'
AS $BODY$

	BEGIN
		RETURN QUERY
		   SELECT o.sendersreference, n.alternateid, n.recipientorgno, n.recipientnin, n.mobilenumber, n.result, n.resulttime
			FROM notifications.smsnotifications n
            LEFT JOIN notifications.orders o ON n._orderid = o._id
			WHERE o.alternateid = _alternateorderid
			and o.creatorname = _creatorname;
        IF NOT FOUND THEN
            RETURN QUERY
            SELECT o.sendersreference, NULL::uuid, NULL::text, NULL::text, NULL::text, NULL::smsnotificationresulttype, NULL::timestamptz
            FROM notifications.orders o
            WHERE o.alternateid = _alternateorderid
            and o.creatorname = _creatorname;
        END IF;
	END;
$BODY$;

-- getstatusfeed.sql:
CREATE OR REPLACE FUNCTION notifications.getstatusfeed(
    _sequencenumber BIGINT,
    _creatorname TEXT,
    _limit INTEGER
)
RETURNS TABLE(_id BIGINT, orderstatus jsonb) AS $$
BEGIN
    /*
     * This function retrieves recent status feed entries for a specific creator.
     *
     * PARAMETERS:
     * _sequencenumber: The ID to look after. The function will return rows where _id > this value.
     * _creator_name:   The name of the creator to filter by.
     * _limit:          The maximum number of rows to return.
     *
     * RETURNS:
     * A table with two columns: _id (BIGINT) and orderstatus (TEXT).
     */
    RETURN QUERY
    SELECT
        sf._id,
        sf.orderstatus
    FROM
        notifications.statusfeed AS sf
    WHERE
        sf._id > _sequencenumber
        AND sf.creatorname = _creatorname
        AND sf.created < (NOW() - INTERVAL '2 seconds')
    ORDER BY
        sf._id ASC
    LIMIT
        _limit;
END;
$$ LANGUAGE plpgsql SECURITY INVOKER;

COMMENT ON FUNCTION notifications.getstatusfeed(BIGINT, TEXT, INTEGER) IS 'Retrieves a limited number of statusfeed entries created more than 2 seconds ago for a specific creator, starting after a given sequence number.';


-- insertdeaddeliveryreport.sql:
CREATE OR REPLACE FUNCTION notifications.insertdeaddeliveryreport(
	_channel smallint,
	_attemptcount integer,
	_deliveryreport jsonb,
	_resolved boolean,
	_firstseen timestamp with time zone,
	_lastattempt timestamp with time zone,
	_reason text DEFAULT NULL,
	_message text DEFAULT NULL)
    RETURNS BIGINT
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
	new_id BIGINT;
BEGIN
    -- Insert the delivery report into the dead delivery report table
    INSERT INTO notifications.deaddeliveryreports (channel, attemptcount, deliveryreport, resolved, firstseen, lastattempt, reason, message)
    VALUES (_channel, _attemptcount, _deliveryreport, _resolved, _firstseen, _lastattempt, _reason, _message)
	RETURNING id INTO new_id;

	RETURN new_id;
END;
$BODY$;

ALTER FUNCTION notifications.insertdeaddeliveryreport(smallint, integer, jsonb, boolean, timestamp with time zone, timestamp with time zone, text, text)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.insertdeaddeliveryreport(smallint, integer, jsonb, boolean, timestamp with time zone, timestamp with time zone, text, text)
    IS 'This function inserts a new delivery report record into the notifications.deaddeliveryreports table.

Arguments:
- _channel (smallint): The unique identifier for the channel, meaning what type of delivery report to expect.
- _attemptcount (integer): Tracks how many times the API has attempted to consume the message.
- _deliveryreport (jsonb): A JSONB object containing the details of the delivery report.
- _resolved (boolean): A flag indicating whether the delivery issue has been resolved.
- _firstseen (TIMESTAMPTZ): The timestamp when the delivery issue was first detected.
- _lastattempt (TIMESTAMPTZ): The timestamp of the last delivery attempt.
- _reason (text): Optional reason code for why the delivery failed (e.g., "RETRY_THRESHOLD_EXCEEDED", "NOTIFICATION_EXPIRED").
- _message (text): Optional human-readable message describing why the delivery failed.';


-- insertemailnotification.sql:
CREATE OR REPLACE PROCEDURE notifications.insertemailnotification(
    _orderid uuid,
    _alternateid uuid,
    _recipientorgno TEXT,
    _recipientnin TEXT,
    _toaddress TEXT,
    _customizedbody TEXT,
    _customizedsubject TEXT,
    _result TEXT,
    _resulttime timestamptz,
    _expirytime timestamptz
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    __orderid BIGINT;
BEGIN
    SELECT _id INTO __orderid 
    FROM notifications.orders
    WHERE alternateid = _orderid;

    INSERT INTO notifications.emailnotifications(
        _orderid,
        alternateid,
        recipientorgno,
        recipientnin,
        toaddress,
        customizedbody,
        customizedsubject,
        result,
        resulttime,
        expirytime
    )
    VALUES (
        __orderid,
        _alternateid,
        _recipientorgno,
        _recipientnin,
        _toaddress,
        _customizedbody,
        _customizedsubject,
        _result::emailnotificationresulttype,
        _resulttime,
        _expirytime
    );
END;
$BODY$;

-- insertemailtext.sql:
CREATE OR REPLACE PROCEDURE notifications.insertemailtext(__orderid BIGINT, _fromaddress TEXT, _subject TEXT, _body TEXT, _contenttype TEXT)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
INSERT INTO notifications.emailtexts(_orderid, fromaddress, subject, body, contenttype)
	VALUES (__orderid, _fromaddress, _subject, _body, _contenttype);
END;
$BODY$;


-- insertorder.sql:
CREATE OR REPLACE FUNCTION notifications.insertorder(_alternateid UUID, _creatorname TEXT, _sendersreference TEXT, _created TIMESTAMPTZ, _requestedsendtime TIMESTAMPTZ, _notificationorder JSONB)
RETURNS BIGINT
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Postgres supports function overloading - so this function has the same name, but one additional parameter: sendingTimePolicy
CREATE OR REPLACE FUNCTION notifications.insertorder(
	_alternateid uuid,
	_creatorname text,
	_sendersreference text,
	_created timestamp with time zone,
	_requestedsendtime timestamp with time zone,
	_notificationorder jsonb,
	_sendingtimepolicy integer)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$

DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Add new overload that includes the 'type' parameter
CREATE OR REPLACE FUNCTION notifications.insertorder(
	_alternateid uuid,
	_creatorname text,
	_sendersreference text,
	_created timestamp with time zone,
	_requestedsendtime timestamp with time zone,
	_notificationorder jsonb,
	_sendingtimepolicy integer,
	_type text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$

DECLARE
_orderid BIGINT;
BEGIN
	INSERT INTO notifications.orders(alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy, type) 
	VALUES (_alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy, _type::public.notificationordertype)
   RETURNING _id INTO _orderid;
   
   RETURN _orderid;
END;
$BODY$;

-- Overload: Adds the 'processedstatus' parameter to allow explicit setting of the order's processing state.
CREATE OR REPLACE FUNCTION notifications.insertorder(
    _alternateid uuid,
    _creatorname text,
    _sendersreference text,
    _created timestamp with time zone,
    _requestedsendtime timestamp with time zone,
    _notificationorder jsonb,
    _sendingtimepolicy integer,
    _type text,
    _processingstatus text
)
RETURNS bigint
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    _orderid BIGINT;
BEGIN
    INSERT INTO notifications.orders(
        alternateid, creatorname, sendersreference, created, requestedsendtime, processed, notificationorder, sendingtimepolicy, type, processedstatus
    )
    VALUES (
        _alternateid, _creatorname, _sendersreference, _created, _requestedsendtime, _created, _notificationorder, _sendingtimepolicy, _type::public.notificationordertype, _processingstatus::public.orderprocessingstate
    )
    RETURNING _id INTO _orderid;

    RETURN _orderid;
END;
$BODY$;

-- insertorderchain.sql:
CREATE OR REPLACE PROCEDURE notifications.insertorderchain(
    _orderid UUID,
    _idempotencyid TEXT,
    _creatorname TEXT,
    _created TIMESTAMP with time zone,
    _orderchain JSONB
)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    INSERT INTO notifications.orderschain(
        orderid,
        idempotencyid,
        creatorname,
        created,
        processed,
        orderchain
    )
    VALUES (
        _orderid,
        _idempotencyid,
        _creatorname,
        _created,
        _created,
        _orderchain
    );
END;
$BODY$;


-- insertsmsnotification.sql:
CREATE OR REPLACE PROCEDURE notifications.insertsmsnotification(
    _orderid uuid,
    _alternateid uuid,
    _recipientorgno TEXT,
    _recipientnin TEXT,
    _mobilenumber TEXT,
    _customizedbody TEXT,
    _result TEXT,
    _smscount integer,
    _resulttime timestamptz,
    _expirytime timestamptz
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    __orderid BIGINT;
BEGIN
    SELECT _id INTO __orderid 
    FROM notifications.orders
    WHERE alternateid = _orderid;

    INSERT INTO notifications.smsnotifications(
        _orderid,
        alternateid,
        recipientorgno,
        recipientnin,
        mobilenumber,
        customizedbody,
        result,
        smscount,
        resulttime,
        expirytime
    )
    VALUES (
        __orderid,
        _alternateid,
        _recipientorgno,
        _recipientnin,
        _mobilenumber,
        _customizedbody,
        _result::smsnotificationresulttype,
        _smscount,
        _resulttime,
        _expirytime
    );
END;
$BODY$;

-- insertstatusfeed.sql:
-- FUNCTION: notifications.insertstatusfeed(bigint, text, jsonb)

-- DROP FUNCTION IF EXISTS notifications.insertstatusfeed(bigint, text, jsonb);

CREATE OR REPLACE FUNCTION notifications.insertstatusfeed(
	_orderid bigint,
	_creatorname text,
	_orderstatus jsonb)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    -- Insert the new status into the 'statusfeed' table
    INSERT INTO notifications.statusfeed (orderid, creatorname, created, orderstatus)
    VALUES (_orderid, _creatorname, now(), _orderstatus);
END;
$BODY$;

ALTER FUNCTION notifications.insertstatusfeed(bigint, text, jsonb)
    OWNER TO platform_notifications_admin;

COMMENT ON FUNCTION notifications.insertstatusfeed(bigint, text, jsonb) IS
'This function inserts a new status update record into the `notifications.statusfeed` table.

Arguments:
- _orderid (bigint): The unique identifier for the order being updated.
- _creatorname (text): The name of the service owner for which  the status entry is relevant.
- _orderstatus (jsonb): A JSONB object containing the specific details of the order status at this point in time.

The function automatically records the current timestamp (`now()`) for the `created` column upon insertion. It returns void.';


-- trymarkorderascompleted.sql:
CREATE OR REPLACE FUNCTION notifications.trymarkorderascompleted(_alternateid uuid, _alternateidsource text)
RETURNS boolean AS $$
DECLARE
    order_id bigint;
    order_status orderprocessingstate;
    has_pending_notifications boolean := false;
BEGIN
    IF _alternateid IS NULL THEN
        RAISE EXCEPTION 'Notification ID cannot be null';
    END IF;

    IF _alternateidsource IS NULL OR LENGTH(TRIM(_alternateidsource)) = 0 THEN
        RAISE EXCEPTION 'Notification type cannot be null or empty';
    END IF;

    -- Convert notification type to uppercase for case-insensitive comparison
    _alternateidsource := UPPER(TRIM(_alternateidsource));

    -- Step 2: Find the order ID based on notification type
    CASE _alternateidsource
        WHEN 'SMS' THEN
            SELECT _orderid INTO order_id 
            FROM notifications.smsnotifications 
            WHERE alternateid = _alternateid
            LIMIT 1;

        WHEN 'EMAIL' THEN
            SELECT _orderid INTO order_id 
            FROM notifications.emailnotifications 
            WHERE alternateid = _alternateid
            LIMIT 1;

        WHEN 'ORDER' THEN
            SELECT _id INTO order_id
            FROM notifications.orders
            WHERE alternateid = _alternateid
            LIMIT 1;

        ELSE
            RAISE EXCEPTION 'Invalid notification type: %. Must be one of: SMS, EMAIL, ORDER', _alternateidsource;
    END CASE;

    -- Step 3: Validate order ID exists
    IF order_id IS NULL THEN
        RAISE EXCEPTION 'No order found for notification ID % with source type %', _alternateid, _alternateidsource;
    END IF;

    -- Step 4: Check if order is already completed (with row lock)
    SELECT processedstatus INTO order_status
    FROM notifications.orders
    WHERE _id = order_id
    FOR UPDATE;

    IF order_status IS NULL OR (order_status <> 'Processing'::orderprocessingstate AND order_status <> 'Processed'::orderprocessingstate) THEN
        RETURN false;
    END IF;

    -- Step 5: Check if any notifications are still pending
    WITH pending_notifications AS (
        SELECT 1 AS is_pending
        FROM notifications.smsnotifications 
        WHERE _orderid = order_id 
        AND result IN ('New'::smsnotificationresulttype, 'Sending'::smsnotificationresulttype, 'Accepted'::smsnotificationresulttype)

        UNION ALL

        SELECT 1 AS is_pending
        FROM notifications.emailnotifications 
        WHERE _orderid = order_id 
        AND result IN ('New'::emailnotificationresulttype, 'Sending'::emailnotificationresulttype, 'Succeeded'::emailnotificationresulttype)
    )
    SELECT EXISTS(SELECT 1 FROM pending_notifications) INTO has_pending_notifications;

    -- Step 6: Update order status based on notification states
    UPDATE notifications.orders
    SET processedstatus = CASE 
                            WHEN has_pending_notifications THEN 'Processed'
                            ELSE 'Completed'
                          END::orderprocessingstate,
        processed = CURRENT_TIMESTAMP
    WHERE _id = order_id
    AND processedstatus IS DISTINCT FROM (CASE WHEN has_pending_notifications THEN 'Processed' ELSE 'Completed' END::orderprocessingstate);

    RETURN NOT has_pending_notifications;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION notifications.trymarkorderascompleted IS 
'Attempts to mark a notification order as completed based on the status
of its associated SMS and Email notifications. The function updates the order''s
status to ''Completed'' only if all associated notifications are no longer pending.

Parameters:
  _alternateid uuid       - The UUID identifier for the SMS, Email notifications or order
  _alternateidsource text - The source type, must be one of: ''SMS'', ''EMAIL'', or ''ORDER'' (case-insensitive)

Returns:
  boolean - TRUE if the order was successfully marked as completed
          FALSE if the order cannot be completed (already completed or has pending notifications)

Side Effects:
  - Updates the processedstatus and processed timestamp in notifications.orders table
  - Sets order status to ''Completed'' when no pending notifications exist
  - Sets order status to ''Processed'' when pending notifications still exist

Throws:
  - Exception if _alternateid is NULL
  - Exception if _alternateidsource is NULL or empty
  - Exception if _alternateidsource is not one of: ''SMS'', ''EMAIL'', ''ORDER''
  - Exception if no order is found for the given notification ID and source';

-- updateemailnotification.sql:
CREATE OR REPLACE FUNCTION notifications.updateemailnotification(
    _result text,
    _operationid text,
    _alternateid uuid
)
RETURNS uuid
LANGUAGE plpgsql
AS $$
DECLARE
    v_alternateid uuid;
BEGIN
    IF _alternateid IS NOT NULL THEN
        UPDATE notifications.emailnotifications
        SET result = _result::emailnotificationresulttype,
            resulttime = now(),
            operationid = COALESCE(_operationid, operationid)
        WHERE alternateid = _alternateid
        RETURNING alternateid INTO v_alternateid;


    ELSIF _operationid IS NOT NULL THEN
        UPDATE notifications.emailnotifications
        SET result = _result::emailnotificationresulttype,
            resulttime = now()
        WHERE operationid = _operationid
        RETURNING alternateid INTO v_alternateid;
    END IF;

    RETURN v_alternateid; -- null => not found
END;
$$;

COMMENT ON FUNCTION notifications.updateemailnotification IS
'Updates an email notification''s result and resulttime by alternateid or by operationid.
Precedence: If both _alternateid and _operationid are non-null, only alternateid is used for lookup; _operationid may still populate the row via COALESCE.
Null return: NULL when neither identifier is provided OR no matching row exists (no update performed).
Uniqueness assumptions: alternateid is unique (primary key); operationid uniquely identifies at most one row when non-null.
Overwrite policy: result and resulttime are always overwritten (no transition guarding); operationid is only set when a non-null _operationid is supplied (existing value preserved when _operationid is null).';

-- updateemailstatus.sql:
CREATE OR REPLACE PROCEDURE notifications.updateemailstatus(_alternateid UUID, _result text, _operationid text)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
	UPDATE notifications.emailnotifications 
	SET result = _result::emailnotificationresulttype, resulttime = now(), operationid = _operationid
	WHERE alternateid = _alternateid;
END;
$BODY$;

-- updateexpirednotifications.sql:
CREATE OR REPLACE FUNCTION notifications.updateexpirednotifications(
    _source TEXT,
    _limit INT,
    _expiry_offset_seconds INT DEFAULT 300
)
RETURNS SETOF UUID
LANGUAGE plpgsql
AS $$
BEGIN
    -- Validate inputs
        IF _limit <= 0 THEN
            RAISE EXCEPTION 'Limit must be greater than 0';
        END IF;

    -- Use lower() for case-insensitive comparison of the notification type
    IF lower(_source) = 'email' THEN
        -- If the type is 'email', run the update on the emailnotifications table
        RETURN QUERY
        WITH claimed_rows AS (
            SELECT _id
            FROM notifications.emailnotifications
            WHERE result = 'Succeeded'::emailnotificationresulttype AND expirytime < (now() - make_interval(secs => _expiry_offset_seconds))
            ORDER BY expirytime ASC, _id
            FOR UPDATE SKIP LOCKED
            LIMIT _limit
        ),
        updated_rows AS (
            UPDATE notifications.emailnotifications
            SET result = 'Failed_TTL'::emailnotificationresulttype,
                resulttime = now()
            WHERE _id IN (SELECT _id FROM claimed_rows)
            RETURNING alternateid -- Return all alternateids from updated rows
        )
        -- Select the unique alternateids from the CTE
        SELECT alternateid
        FROM updated_rows;

    ELSIF lower(_source) = 'sms' THEN
        -- If the type is 'sms', run the update on the smsnotifications table
        RETURN QUERY
        WITH claimed_rows AS (
            SELECT _id
            FROM notifications.smsnotifications
            WHERE result = 'Accepted'::smsnotificationresulttype AND expirytime < (now() - make_interval(secs => _expiry_offset_seconds))
            ORDER BY expirytime ASC, _id
            FOR UPDATE SKIP LOCKED
            LIMIT _limit
        ),
        updated_rows AS (
            UPDATE notifications.smsnotifications
            SET result = 'Failed_TTL'::smsnotificationresulttype,
                resulttime = now()
            WHERE _id IN (SELECT _id FROM claimed_rows)
            RETURNING alternateid -- Return all alternateids from updated rows
        )
        -- Select the unique alternateids from the CTE
        SELECT alternateid
        FROM updated_rows;
        
    ELSE
        -- Throw an exception if an invalid type was provided
        RAISE EXCEPTION 'Invalid notification type: %. Allowed values are ''email'' or ''sms''.', _source;
    END IF;

END;
$$;

-- Add a comment to the function for documentation purposes
COMMENT ON FUNCTION notifications.updateexpirednotifications(TEXT, INT, INT) IS 
'Use row-level locking to support concurrent calls. Updates the result of expired email or sms notifications to ''Failed_TTL''. 
Parameters: 
- _source (TEXT): notification type (''email'' or ''sms'')
- _limit (INT): maximum number of records to update
- _expiry_offset_seconds (INT): grace period in seconds before marking as expired (default: 300)
Returns a set of unique alternateid for the updated records.';


